---
{"dg-publish":true,"permalink":"//os/multi-processing-vs-multi-threading/","title":"멀티프로세싱 vs 멀티 스레딩","tags":["os"]}
---


![Pasted image 20231129145831.png](/images/Pasted%20image%2020231129145831.png)![Pasted image 20231129145844.png](/images/Pasted%20image%2020231129145844.png)
운영체제가 PCB를 관리하는 방식과 TCB의 그림이다. 

>PCB 는 os 스케줄링에 의해 Context Switching 되고
>TCB 는  스레드 라이브러리에 의해 Context Switching 된다.

그래서  막연히 TCB ,즉 멀티 스레딩 환경에서 더 적은 비용해 무조건적으로 Threading 방식이 보다 우수하다고 생각하고 있었는데, 아래 링크의 글을 읽고 아님을 알게되었다.
*Flask 프로젝트 에서 동시에 작업해야하는 상황이 있었는데 MultiThreding 방식이 더 좋지 않을까 했지만, GIL의 존재때문에 fork() 시켰었다. *


[출처] https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-Is-more-threads-always-better

링크의 글을 간략하게 정리하고자한다.
## 1. 임계 영역에 대한 동기화 비용
---
-  임계영역 동기화 문제 
-    Cpu 캐시 , 메모리 데이터 일관성 문제

>멀티 스레드 프로그램이 많은 양의 공유 데이터를 사용하는 경우 동기화 및 캐시 일관성 작업으로 인해 병목이 일어나 성능이 떨어진다
## 2. 컨텍스트 스위칭 오버헤드
---
![Pasted image 20231129152956.jpg](/images/Pasted%20image%2020231129152956.jpg)
 
 >멀티 프로세스 대신 멀티 스레드로 프로그램 모델을 구성하는 이유는 프로세스의 컨텍스트 스위칭 오버헤드 보다 스레드의 컨텍스트 스위칭 오버헤드가 훨씬 작아 병목이 적기 때문이다. 하지만 어디까지나 프로세스에 비해 상대적으로 작다는 것이지 오버헤드 자체 비용은 결코 무시할수는 없다.


## 3. 잔여 스레드의 리소스 낭비
---
> 잔여 스레드들이 CPU, 메모리, 네트워크 등의 자원을 불필요하게 점유해서 성능 저하나 오류의 원인이 될 수 있게 된다. 
> 그런데 놀고 있음에도 CPU는 다른 스레드에게 CPU 시간을 양도하도록 설계 되어 있기 때문에 **노는 스레드와 다른 스레드 간에 컨텍스트 스위칭**을 하여 CPU의 효율성을 떨어뜨린다. 


## 결론
---
##### **CPU 바운드 어플리케이션
- 데이터 마이닝, 영상 처리 작업, 이미지 프로세싱, 암호화폐 마이닝 ..등  
>각 코어에 쓰레드가 많아지면 컨텍스트 스위칭만 늘어나 성능이 저하된다.
#### I/O 바운드 어플리케이션



![Pasted image 20231129161755.png](/images/Pasted%20image%2020231129161755.png)
멀티 스레드는 I/O 작업이 처리될 동안 다음에 이행할 작업들을 다른 스레드에게 자원을 할당하여 수행할 수 있도록 할 수 있다. 네트워크 통신도 마찬가지로 네트워크 상황에 따라 전송 시간이 오래 걸릴 수 있으므로 통신 지연동안 스레드를 재활용 시키는 것이다.

> I/o 작업하는 해당 장비 ( 네트워크 장비 ,메모리, 하드 ) 와 통신하는데 걸리는 시간이 존재 

#### (event loop 기반)
![Pasted image 20231129162340.png](/images/Pasted%20image%2020231129162340.png)