---
{"dg-publish":true,"permalink":"//jvm/2/"}
---



## 2.2 런타임 데이터 영역
---
프로그램이 실행 하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다.

![JVM 구조.png](/img/user/images/JVM-구조.png)

####  프로그램 카운터
- 현재 실행 중인 스레드의 **바이트 코드 줄 번호 표시기**
- 바이트 코드 인터프리터는 이 값을 조작해  프로그램의 제어흐름, 분기, 순환, 점프를 구현함
- context switch 과정에서 실행하다 멈춘 지점을 복원하기 위해 저장하는 장소
- **스레드 프라이빗** : 스레드 간 서로 영향을 주지 않는 독립적인 영역

#### 자바 가상 머신 스택
- 스레드 프라이빗의 성질을 가지고 있다.
- 스레드와 같은 생명 주기를 갖는다.
- 가상 머신 스택에 **스택 프레임** ( **지역 변수 테이블**, 피연산자 스택, 동적 링크, 메서드 반환 값의 집합)을 `push, pop` 한다.
- **지역 변수 테이블** : 컴파일 타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입들이 저장 된다.

#### 자바 힙
- **모든 스레드가 공유**하며 가상머신이 구동 될때 만들어진다.
- 객체 인스턴스를 저장한다.
- 가비지 컬렉터가 가 관리하는 영역이다.

#### 메서드 영역
- **모든 스레드가 공유**
- 타입 정보, 상수, 정적 변수, 코드 캐시 등을 저장
- 초기에는 영구 세대에 메서드 영역을 구현 하여 가비지 컬렉터로 관리할 수 있었다.
- 그러나, 영구 세대에 메서드 영역에 구현한 것은 메모리 오버플로를 겪을 가능성이 커져 **네이티브 메모리의 메타스페이스**에 구현하는 방식으로 변경했다.
- *정적 변수, String 은 heap 으로 이동되었다.*

#### 런타임 상수 풀
- 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.
- 클래스 파일과 상수풀과의 차이점은 런타임 상수풀은 동적이라는 점이다.
- *런타임 상수 풀은 JVM이 클래스를 로드할 때 클래스 파일 상수 풀을 기반으로 생성되는 데이터 구조이다.*
- 동적 메서드 호출, 리플렉션 등과 같은 기능을 지원한다.

> 컴파일 타임에는 클래스 파일 상수 풀이 사용되며, 런타임에는 JVM이 이 정보를 바탕으로 런타임 상수 풀을 구성하여 프로그램을 실행한다.


#### 다이렉트 메모리
- 가상 머신 런타임에 속하지 않으며 물리 메모리에 직접 할당 할 수 있는 메모리
- 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼서 성능이 향상된다.


## 2.3 핫스팟 가상 머신에서의 객체 들여다보기

#### 객체 생성
**`new` 키워드를 만나면 가상 머신의 작업 순서**

1. 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인
2. 심벌 참조가 뜻하는 클래스가 로딩,해석,초기화 되었는지 확인
3. 클래스 로딩 과정이 없었다면 로딩 시작
4. 로딩이 완료된 클래스라면 새 객체를 위한 메모리 할당

- **여유 목록 할당 방식** : JVM 은 가용한 메모리 블록을 관리하여 객체 인스턴스를 담기 충분한 공간을 찾아 할당 한다. 
- 여러 스레드가 존재할 때 메모리 할당 방식은 스레드 안전하지 않은데 아래의 두가지 방법을 사용해 해결한다.
	- **CAS , 실패 시 재시도 방식**
	- **스레드 로컬 할당 버퍼 ( TLAB )**
		- 힙 내에 작은 크기의 스레드 전용 메모리를 할당한다.
		- 각 스레드는 각자의 TLAB을 사용하다 버퍼가 부족해질 때 동기화 후 새로운 버퍼를 할당 받는다.

5. 할당 받은 공간 0 으로 초기화
6. 객체 헤더 설정
7. `new` 명령어에 이어 `init()` 메서드 실행해 사용 가능한 객체 완성

#### 객체의 메모리 레이아웃
- JVM 에서 객체를 힙에 저장하는 구조
![자바 객체 메모리 레이아웃.png](/img/user/images/자바-객체-메모리-레이아웃.png)

**객체 헤더**
- **객체의 런타임 데이터 (마크 워드)**
	- 해시 코드
	- gc세대 나이
	- 락 상태 플래그
	- 스레드가 점유하고 있는 락들
- **클래스 워드 (klass word)**
	- 객체의 **클래스관련 메타 데이터**를 가리키는 클래스 포인터가 저장된다.
	- 클래스 포인터를 통해 런타임에 해당 객체가 어떤 클래스인지 확인할 수 있다.
- **배열 길이 (배열일 경우 존재)**


**인스턴스 데이터**
- 객체가 실제 담고 있는 정보, 코드에서 정의한 다양한 타입의 필드 관련 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 기록된다.

**정렬 패딩**
- JVM 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8 바이트의 정수배여야 하므로 패딩 값을 추가한다.



#### 객체에 접근하기
- 스택에 있는 참조 데이터를 통해 힙에  들어있는 객체에 접근한다. 참조방식에는 두가지가 존재한다.
	- **핸들 방식 방식** : 
	  ![자바 핸들 방식 객체 접근.png](/img/user/images/자바-핸들-방식-객체-접근.png)
	  자바 힙에 **핸들 저장 풀**이 존재하고 **객체 인스턴스 데이터를 가리키는 포인터**, **객체 타입을 가리키는 포인터**가 존재한다.
		- GC에서 객체 주소가 변경되는 일이 흔한데, 핸들을 사용하면 객체의 위치가 변경될 때 인스턴스 데이터 포인터를 변경하면 되기 때문에 안정적인 핸들의 주소를 저장할 수 있다.
	- **다이렉트 포인터 방식** : 
	  ![자바 객체 다이렉트 포인터 메모리 접근.png](/img/user/images/자바-객체-다이렉트-포인터-메모리-접근.png)
	  자바 힙에 위치한 객체에 객체의 실제 주소가 저장되어 있다.
		- **인스턴스 데이터에 접근하기위해 포인터를 한번 더 경유하지 않아도 된다. **
		- 핸들을 경유하지 않아 속도가 빠르다.
		- 핫스팟은 주로 다이렉트 포인터 방식을 사용한다.






