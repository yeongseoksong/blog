---
{"dg-publish":true,"permalink":"//jvm/13/"}
---


```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false

```
## 13.2 스레드 안전성
---
**스레드 안전성**은 동기화 등의 안전장치를 코드 자체에 완벽하게 내장해서, 호출자는 멀티스레드 환경인지 고려하지 않아도 안전하게 사용할 수 있어야 함을 의미한다.

#### 자바 언어의 스레드 안전성
- 스레드의 안전성은 이분법적이 아닌 아래의 5가지로 분류 된다.
	- **불변**
		- final
		- Enum
		- String
		- Number
	- **절대적 스레드 안전**
	  - 어떤 런타임 환경에서든 호출자가 추가적 동기화 조치를 할 필요 없다.
	  - 자바 API 는 대부분 절대적 스레드 안전이 아니다.
	- **조건부 스레드 안전**
		- 일반적으로 thread safe 하다고 말할때의 안전 수준
		- 단일한 작업을 별도로 보호 조치 없이 thread safe 로 수행
		- 특정 경우에 따라 동기화 조치 필요
		- `synchronized()` 로 래핑한 컬렉션 `HashTable, Vector`
	- **스레드 호환**
		- 객체 자체가 thread safe 하지 않지만, 호출자가 적절히 조치를 취하면 멀티스레딩 환경에서 안전하게 사용 가능하다.
		- `ArrayList, HashMap` 이 이에 해당
	- **스레드 적대적**
		- 호출자가 동기화 조취를 취하더라도 멀티스레드 환경에서 안전하게 사용할 수 없음




#### 스레드 안전성 구현

[[책/운영체제/6장. 동기화 도구\|6장. 동기화 도구]] 참고

**상호 배제 동기화**
- **상호 배제 동기화** 의 기본적인 수단으로 `synchronized`가 존재한다.
- 락을 수행하면 대기해야하는 다른 스레드들은 대기 하게 되는데, 사용자 스레드와 커널 스레드가 매핑 되는 JVM 에서는 잠들어 있는 스레드들을 깨우기 위해 커널모드로의 전환이 필요하다. 이는 성능에 악영향을 준다.
- 그렇기 때문에 JVM 은 최적화를 수행하는데 스레드를 대기큐로 이동 시키기는 것 대신에 spinlock 을 사용하게 한다.
- jdk5 이후 새로운 동기화 도구인 `ReentLock` 이 추가 되었다. 아래의 추가적인 기능을 제공한다.
	- 대기 중인 인터럽트 : 대기 중인 다른 스레드들이 락을 포기하고 다른 작업을 수행 할 수 있게 해준다.
	- 페어 락 : 대기하는 스레드들이 많을때 lock 획득을 시도한 시간 순서대로  lock 을 획득한다.
	- 둘 이상의 조건 지정


**논블로킹 동기화**
- **비관적 동시성 전략**  : 동기화 장치가 없으면 문제가 생길 것이라 가정 후 경합의 발생 여부와 상관없이 락을 건다. 
	- 상호 배제 동기화가 이에 해당, 
	- **blocking 동기화**
- **낙관적 동시성 전략** : 충돌 감지를 기반으로 작동하는데, 잠재적으로 위험할 수 있더라도 작업을 수행하고 만일 충돌이 있으면 조치를 취한다. 
	- **non-blocking 동기화** 
	- 락프리 프로그래밍 : non-blocking 동기화,**낙관적 동시성 전략**을 따르는 코딩
	- 작업의 진행과 충돌 감지가 한 명령어 처리처럼 수행되어야 하기 때문에 **낙관적 동시성** 전략에는 하드웨어 명령어 집합의 발전이 필요했다.
- **CAS ( compare-and-Swap )**
	- 메모리 위치 ( V ) ,예상되는 이전 값 ( A ) , 새로 설정할 값 ( B )
	- V의 값이 A와 같다면 B 로 갱신 , 다르면 갱신을 수행하지 않음
	- 이 작입어 원자적으로 수행되어 다른 스레드가 끼어들지 못한다.
	- `VarHandle` 이 cas 연산을 사용할 수 있게 해준다.
	- ABA 문제: V 에서 읽어들인 값이 A 이고 이를 비교하려고 할때 다른 스레드가 값을 A -> B -> A 로 두번 바꾸었을때 예상되는 값과 V의 값이 여전히 같기때문에 B로 값을 갱신할것이다.
	- ABA 문제는 프로그램 동시성의 정확성에 영향을 주지 않는다. 만약 ABA 문제를 해결해야 한다면 상호 배제 동기화 도구를 사용하는 것이 효율적이다.

**동기화가 필요 없는 메커니즘**
- 공유 데이터가 존재 하지 않으면 race condition도 존재하지 않으므로 이 상황에서는 동기화가 필요없다. 아래의 두가지 유형이 존재한다.
	- 순수 코드 : 실행 중간에 아무 떄나 끼어 들어 다른 코드를 수행하고 와도 상관 없는 코드 , 전역변수, 힙에 저장된 데이터, 재진입 불가능 코드 호출 을 하지 않음
	- 스레드 로컬 저장소 
> 순수 코드는 함수형 프로그래밍에서의 pure function을 의미하는 것 같다. 즉, side effect가 존재하지 않는 함수 


## 13.3 락 최적화
---
데이터를 더 효율적으로 공유하고 스레드 사이의 race condition 를 해결해 프로그램 성능을 높이기 위해 락 최적화 기술을 사용한다



**스핀 락과 적응형 스핀**
- 스레드를 wait 하고 다시 ready queue 로 넣어 주는 과정에서 <mark style="background: #FFB86CA6;">커널모드로의 전환이 필요해 동시성 성능에 악영향</mark>이 있다.
- 그래서 spinlock ( busy waiting 하는 Mutex lock ) 을 사용한다.
- 스핀락은 스레드 전환 부하는 감소 시켰지만 프로세서 시간을 소비하는 부작용이 있다.
- spin 시간이 고정되어 있지 않고 이전 스핀 시간과 락 소유자의 상태에 따라 결정하는 방식을 **적응형 스핀**이라 한다.

**락 제거**
- 런타임에 데이터 경합이 없다고 판단되는 코드를 <mark style="background: #FFB86CA6;">Jit 컴파일러가 락을 제거</mark>해 최적화 하는 작업

**락 범휘 확장**
- 연이은 다수의 작업이나 순환문에서 같은 락 객체를 반복해 잠면 락 유효 범위를 해당 작업 전체로 변경한다.

**경량 락**
- 운영체제의 Mutex 를 사용해 구현한 기존 lock 보다 가벼움
- 경량락은 스레드 경합을 없애 뮤텍스를 사용하는 기존 중량 락의 성능 저하를 줄이는게 목적이다.
- Mutex 대신 <mark style="background: #FFB86CA6;">CAS 연산을 활용</mark>한다.
- 대부분의 락은 경합이 없다는 경험에 의거해 동기화 성능을 개선한다. **(낙관적 동시성 전략)**
- 그러나 만약 락에 경합이 존재하면 Mutex, 와 CAS 연산을 모두 사용해 중량락 보다 성능이 느려진다.


**편향 락**
- 경합이 없을 때 데이터의 동기화 장치들을 제거하여 프로그램 실행 성능을 높힌다.
- 경량 락의 CAS 연산 조차 없애 전체 동기화를 없앰
- **제거 되었음**




