---
{"dg-publish":true,"permalink":"//jvm/12/"}
---



```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false

```
## 12.2 하드웨어에서의 효율과 일관성
---
- 메모리 i/o 를 줄이기 위하여 캐시를 사용하는데 멀티 프로세서 시스템에서는 캐시의 일관성 문제가 발생한다.
- 각 프로세서가 캐시를 동기화 하기 위해 정해진 프로토콜을 사용한다.
- 비순차 실행 최적화 : 프로세서가 명령어를 실행하는 순서가 코드에 입력된 순서와 다르게 수행하는 기법
- 명령어 재정렬 최적화 : Jit 컴파일러가 비순차 실행 최적화를 비슷하게 구현함

## 12.3 자바 메모리 모델
---
- 다양한 하드웨어, 운영체제의 서로 다른 메모리 모델로 부터 자바 프로그램을 보호 하고자 정의함
#### 메인 메모리와 작업 메모리

- 자바 메모리 모델의 목적은 프로그램에서 변수에 접근하는 규칙을 정의 하는것
- 이때 변수는 지역 변수, 메서드 매개 변수는 자바 스택의 지역 변수 테이블에 존재하므로 제외된다.
- 자바 메모리 모델은 모든 변수가 메인 메모리 ( 물리적 메인 메모리가 아닌 가상 머신이 관리하는 메모리 )에 저장된다고 규정한다.
- 각 스레드는 작업 메모리를 갖는다.
- 자바 힙, 스택, 메서드 영역과 다른 수준의 구분 방식이다.
- **메인 메모리**는 자바 힙의 인스턴스, 하드웨어에 메모리 대응 되며, 
- **작업 메모리**는 가상 머신의 스택, 하드웨어의 캐시와 레지스터에 대응된다.

#### 메모리 간 상호 작용
- 작업 메모리와 메인 메모리 사이에는 프로토콜이 존재한다고 했는데 구체적인 방법은 8 가지로 정의된다.
	1. 잠금 ( lock )
	2. 잠금 해제 ( unlock )
	3. **읽기 ( read )**
	   메인 메모리의 변수 값을 특정 스레드의 작업 메모리로 전송
	4. **적재 ( load )**
	   **읽기 연산**으로 메인 메모리에서 얻어온 값을 작업 메모리의 변수에 복사
	5. 사용 ( use )
	   작업 메모리의 변수 값을 실행 엔진으로 전달
	6. 할당 ( assgin )
	   실행 엔진에서 받은 값을 작업 메모리의 변수에 할당
	7. **저장 ( store )**
	   **쓰기 연산**을 위해 작업 메모리 변수값을 메인 메모리로 전송
	8. **쓰기 ( write )**
	   **저장 연산**으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록

- 자바 메모리 모델의 연산은 **읽기, 쓰기, 잠금, 잠금 해제**로 단순화되어있음


#### volatile 변수용 특별 규칙


**volite 변수의 특징**
1. **모든 스레드에서 이 변수를 투명하게 볼 수 있다. ( 가시성을 보장 )**
  - *자바의 산술 연산자가 원자적이 아니여서 멀티스레드 환경에서 완벽하게 안전하지는 못하다.*
2. 명령어 재정렬 최적화를 막아준다.
	- *하드웨어가 기계어를 실행할때 의존적이지 않은 명령어 사이의 순서는 최적화 될 수 있어 실행 순서가 변경된다.*
	- volite은 메모리 장벽과 같은 기능을 하는 명령어를 사용해 재정렬을 할 수 없도록 막는다.
	- 네이티브 코드에 메모리 장벽 명령어를 다수 끼워 넣어 쓰기 성능이 일반 변수보다 느리다.

> volite은 가시성 보장과, 명령어 재정렬을 막아주지만 원자성 ( lock )을 보장해주지는 못한다.
> 바이트 코트 명령어가 여러개의 기계어로 변환될 수 있기때문에 반드시 원자적으로 수행되지 않기 때문이다.



#### 원자성,가시성, 실행 순서
자바 메모리 모델은 동시성 처리에서 원자성, 가시성, 실행순서를 어떻게 처리하는가?
- **원자성**
  원자성은 연산의 원자성을 의미한다.자바 메모리 모델에서 원자적 변수 연산은 읽기,적재,할당,사용,저장,쓰기 이다. <mark style="background: #FFB86CA6;">즉, 작업 메모리에서 ++와 같은 연산을 수행할 때에는 원자성이 보장되지 않음을 의미하기도 한다.</mark>
  원자성을 더 넓은 범위로 보장해야할때는 `synchronized()`  사용해야한다.
- **가시성**
  공유 변수의 값을 한 스레드가 수정하면 수정결과를 다른 스레드가 즉시 알 수 있다.
	일반 변수는 가시성을 제공 하지 않는다. 또한, 가시성을 확보용으로 아래를 사용할 수 있다.
	- `volatile`
	- `synchronized`
	- `final`
- **실행순서**
	스레드 사이에서도 작업 순서를 보장하기 위해 `volatile,synchronized` 를 제공한다.
	`synchronized`는 `lock` 을 사용해 단 하나의 스레드만 변수에 접근할 수 있어 원자성,가시성,실행 순서를 모두 만족해야하는 상황에 적합하다. 그러나 프로그램 성능응 떨어뜨린다는 단점이 존재한다.


## 12.4 자바와 스레드
---
#### 스레드 구현
`java.lang.Thread` 의 핵심 메서드는 모두 네이티브 코드로 구현되어 있다.
스레드를 구현하는 방법은 아래의 3가지이다.
- 커널 스레드 구현 (1:1)
- 사용자 스레드 구현 (1:N)
- 하이브리드 구현 (M:N) , 사용자 스레드와 lwp 이용

**커널 스레드 구현**
- **특징**
	- 운영체제 커널에서 직접 지원하는 스레드이다. 
	- 스레드 작업을 각 프로세서에 매핑하는 역할을 함
	- 프로그램은 일반적으로 커널 스레드 대신 고수준의 인터페이스인 LWP 사용
- **단점**
	- 시스템 호출로 커널 스레드를 생성해야하기 커널모드,사용자 모드 전환으로 비용발생
	- lwp와 커널 스레드가 매핑 되기 위해서 커널 자원을 소모해 시스템이 지원할 수 있는 lwp의 개수에 제한이 존재한다.

**사용자 스레드 구현**
- **특징**
	- 온전히 사용자 공간에서 구현되는 스레드 라이브러리
	- 사용자 스레드 생성, 소멸, 동기화, 스케줄링이 커널의 도움 없이 처리된다.
- 단점
	- 커널의 지원을 못받기 때문에 구현의 어려움

**하이브리드 구현**
- **특징**
	- 사용자 스레드, 경량 프로세스가 공존함
	- lwp 가 KLT,UT를 연결해주는 역할을 함

#### 자바 스레드 스케줄링
- 선점형 스케줄링을 사용한다.
- `Thread.MIN_PRIORITY, Thread.MAX_PIRORITY` 로 스케줄링 우선 순위를 지정할 수 있지만 운영체제의 스케줄링 우선순위 레벨과 항상 일치하지 않는다.
- 우선순위 부스팅 : 매우 자주 실행된다고 판단되는 스레드의 우선순위를 시스템이 재정의해 실행 시간을 더 할당해줌

**상태 전이**
- 자바의 스레드의 상태는 6가지이다
	- 신규
	- 실행중
	  운영 체제 스레드 상태중 실행중, 준비에 해당
	- 무기한 대기
	  다른 스레드가 명시적으로 꺠워 주기를 기다리는 상태 `wait,join`
	- 시간 제한 대기
	  다른 스레드가 꺠워주기를 기다릴 필요없이 시간이 지나면 꺠어난다.
	- 블록
	  배타적 락을 얻기를 기다리는 상태 `synchroniozed`
	- 종료


## 12.5 자바와 가상 스레드
---
#### 커널 스레드의 한계
MSA 의 등장 이후 요청당 실행 시간이 매우 짧아지고 요청의 수가 증가 했다. 그러나 기존의 1:1 커널 스레드 모델은 스케줄링 비용이 커져 자바의  기존 동시성 프로그래밍 메커니즘은 새로운 해결책이 필요했다.

#### 코루틴의 귀환
문맥 교환 비용은 어플리케이션의 응답속도에 영향을 미친다. 그래서 호출 스택과 스케줄러 등 많은 것을 애플리케이션 수준에서 구현하는 코루틴이 다시 등장 했다.
그러나, 자바로 풀스택 코루틴을 구현하기에 어려움이 존재했다.

#### 가상 스레드: 자바의 해법
스택플 코루틴을 구현한 FIBER, 가상 스레드라고 불린다. 가상 스레드는 기존의 커널스레드방식을 완전히 대체 하는것이 아닌 공존 해 두 가지 동시성 프로그래밍 모델을 제공한다.
- 가상 스레드는 플랫폼 스레드 ( 사용자 스레드 )와 n:1 관계이다.
- 가상 스레드가 block 되면 다른 가상 스레드가 작업을 진행 하기 떄문에 커널 스레드는 문맥 교환 없이 쉬지 않고 실행될 수 있다.
- I/O 작업이 많아서 문맥 교환이 자주 일어나는 작업에서 이점이 있으며, 아닐 경우 효과가 없을 수 있다.
- 가상 스레드는 후속문 ( continuation ) 과 스케줄러로 나누어 지는데 기본 스케줄러로 `ForkJoinPool` 을 사용한다.






