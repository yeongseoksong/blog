---
{"dg-publish":true,"permalink":"///1/"}
---



- 객체들은 각자의 **역할**을 **책임**을 가지고 목표를 달성하기 위해 요청( 메시지 )을 서로 다른 객체들과 **협력**한다
	- 책임을 추상화해 역할을 도출해내고 재사용성을 증대시킬 수 있다.
- **TDA ; Tell, Don't Ask** 객체에 명령을 함으로써 객체에 책임을 위임한다. 
	- 쉽게 객체지향적으로 코드를 작성 가능하게 해주는 원칙
- **VO**
	- **불변성** : 모든 멤버변수 -> `final`, 함수 -> 순수함수, `final class`
	  *불확실성을 최대한 제거할 수 있는 부분과 안고 가야하는 부분을 나누는 것이 중요하다.*
	- **동등성** : 값 객체에 대해 상태가 같다면 같은 객체로 봐 불확실성 해소
	  *식별자는 VO 에 사용할 수 없다. 식별자로써  객체의 동등성을 판단해야 하는데, VO 는 값으로 객체의 동등함을 판단하기 때문이다.*
	- **자가 검증** : 불변 객체를 생성할 때 값을 검증해 틀린 객체가 생성 되는 것을 방지
- **DTO**
	- 매개 변수를 일일이 나열해 전달하는 것이 불편해 데이터를 하나로 묶어 보내려고 만드는 객체에 불과하다.
- **Entity**
	- **엔티티는 데이터로 표현하려는 유무형의 대상**이다. 객체 지향에서는 class, rdb 에서는 테이블로 이를 나타낸다.
		- **도메인 엔티티**
			- 도메인 모델중 **식별자**를 갖거나 **비즈니스 로직을 갖는 모델**들
			- **소프트웨어 개발 분야에서 말하는 엔티티에 해당**
		- **DB 엔티티**
			- 도메인 엔티티와 관련 없이 RDB 에서 어떤 유무형의 객체를 표현 하는데 사용 했던 용어
			- != 도메인 엔티티
		- **JPA 엔티티**
			- 도메인 엔티티와 다르다.
			- 데이터 베이스의 엔티티를 지칭한다.
			- **영속성 객체** 라는 설명이 더 적합하다.

- 객체의 행동을 먼저 고민하면 역할이 자연스럽게 만들어진다. 
- **인터페이스 분리 원칙** 은 기능적 응집도를 따르는 것이다.
	- `jpa repository` 는  너무 많은 역할을 갖는다. 이를 **CQRS** 설계로 세분화 가능하다.
- **의존(dependency) == 결합(coupling)**
	- 모든 의존을 완전 제거하는 것은 불가능, 객체가 협력 하는데 필요한 최소한의 의존이 존재해야 한다.
- **DI** -> 의존 관계를 제거 하는 것이 아닌 약화 시키며, 추상을 사용해 불필요한 의존을 줄인다.
	- *의존성은 어떤 것을 사용하는 것, 의존성 주입은 어떤 것을 외부에서 넣어주는 것*
- **의존성 역전**
	- 세부 사항이 아닌 정책(`interface`) 에 의존 하게한다.
	- 의존성 역전은 **경계를** 만든다.
	  ![dip.png](/img/user/images/dip.png)
	- 경계를 통해 모듈의 상하를 나눌 수 있고, **하위 모듈만 상위 모듈을 의존**하게 만든다.
	  *(상위 모듈이 하위 모듈에 의존하지 않게 시스템을 설계 해야한다.)*
- **의존성 전이** 는 의존성 화살 표방향 역방향으로 전이된다. 즉, A->B->C 의존성을 갖는 관계에서 C 가 변경될 경우 B, A 순으로 변경사항이 전이되는 것을 뜻 한다.
	- *DIP 로 의존성 전이를 끊어낼 수 있다*
- **순환 참조** 를 만들면 안된다.
	- 의존 반향을 단방향으로 만들어야 한다.
- **SOLID** 는 객체지향 설계에 초점을 둔다. 객체는 객체간의 협력, 역할 책임에 초점을 두지만, **SOLID** 는 변경에 유연하고 확장 가능한 코드를 만드는데 초점을 둔다.
	- *높은 응집도, 낮은 결합도*
- 