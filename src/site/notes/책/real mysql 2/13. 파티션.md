---
{"dg-publish":true,"permalink":"//real-mysql-2/13/"}
---



```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false

```

# 13.1 개요
## 13.1.1 파티션을 사용하는 이유
---
- 테이블의 크기가 너무 커 인덱스의 크기가 물리 메모리보다 훨씬 크거나 데이터 특성상 주기적으로 삭제가 필요한 경우 파티션이 필요
### 13.1.1.1 단일 INSERT 와 단일 또는 범위 SELECT의 빠른 처리
- 인덱스가 커지면 `select, insert, update, delete` 쿼리 작업 속도가 느려진다.
- 테이블의 크기가 너무 커 인덱스의 크기가 물리 메모리보다 커지게 되면 쿼리가 상당히 느려진다.
- 파티션은 워킹 셋의 크기를 줄여 물리적 메모리를 효율적이게 사용할 수 있게 해준다.


### 13.1.1.2 데이터의 물리적인 저장소 분리
- MySQL 은 데이터나 인덱스를 파일 단위로 관리한다.
- 파티션을 사용하면 파일 크기를 조절하거나 파티션별 파일들이 저장될 위치나 디스크를 구분해 지정해 해결하는 것도 가능하다.
	- 백업이나, 관리가 수월해진다.
- 파티션 단위로 인덱스를 생성하거나 다른 인덱스를 갖는것은 불가능


### 13.1.1.3 이력 데이터의 효율적인 관리
- 이력 데이터 : 로그 데이터를 의미
- 로그 테이블을 파티션으로 관리하면 불필요한 데이터의 삭제 작업이 단순히 파티션 추가, 삭제 방식으로 간단하고 빠르게 해결 가능하다.
- 또한, 파티션을 사용 안 했을 경우 발생하는 동시성 문제를 해소 가능
## 13.1.2 MySQL 파티션의 내부 처리
```sql
create table tb_article(

article_id int not null,

reg_date datetime not null,

primary key(article_id, reg_date)

) partition by range ( year(reg_date))(

partition p2009 values less than (2010),

partition p2010 values less than (2011),

partition p2012 values less than (2012),

partition p9999 values less than MAXVALUE

);
```



### 13.1.2.1 파티션 테이블의 레코드 INSERT
- `insert` 시에 파티션 키를 보고 저장될 파티션을 결정한다.


### 13.1.2.2 파티션 테이블의 UPDATE
 - `update` 쿼리는 변경 대상 레코드가 어느 파티션에 존재하는지 찾아야한다.
 - `where` 절에 파티션 키가 존재해야 그 대상을 빠르게 검색할 수 있다.
 - **파티션 키 외의 값을 변경하면 칼럼의 값만 변경**하지만,
 - 파티션 키를 변경하면, 해당 파티션에서 해당 레코드를 삭제 후 새로운 파티션에 삽입과정을 거친다.
	 - 파티션 키를 통해 파티션을 선택해야 하기 때문
### 13.1.2.3 파티션 테이블의 검색
- `where` 절 조건으로 검색할 파티션을 선택할 수 있는가?
- `where` 절의 조건이 인덱스를 효율적으로 사용 하는가


| where절 에 사용가능한 조건 | 동작                    |
| ----------------- | --------------------- |
| 파티션 o, 인덱스 o      | 파티션의 인덱스 레인지 스캔       |
| 파티션 x, 인덱스 o      | 파티션마다 인덱스 레인지 스캔 후 병합 |
| 파티션 o, 인덱스 x      | 대상 파티션에 풀 테이블 스캔      |
| 파티션 x, 인덱스 x      | 각 파티션에 풀 테이블 스캔 후 병합  |


### 13.1.2.4 파티션 테이블의 인덱스 스캔과 정렬
- 파티션 테이블의 인덱스는 **로컬 인덱스** 에 해당한다. 
- **로컬 인덱스**란 모든 파티션에 대해 인덱스가 공통적으로 생성됨을 의미한다. 
	- **개별 파티션 단위로 별도의 인덱스를 생성할 수 없음을 의미**
- 파티션과 관계 없이 테이블 전체 단위로 하나의 통합된 인덱스를 지원하는 **글로벌 인덱스** 는 사용 불가하다.
- pk(user_id,date) 로 구성되어 있고, 파티션 키가 (date) 인 경우
	- user_id 칼럼의 값은 파티션의 순서대로 정렬돼 있지 않다.
		- 각 파티션 내에서는 인덱스 순으로 정렬되나, 전체 테이블을 기준으로는 인덱스 순으로 정렬되어 있지 않음을 의미한다.
	- 파티션 테이블은 인덱스 순서대로 읽으면 여러 개의 파티션을 읽고 정렬이 필요하다.
	- 이때, **우선순위 큐를 사용해 병합, 정렬을 수행**한다.


### 13.1.2.5 파티션 푸루닝
- 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제 하는 것

# 13.2 주의사항

## 13.2.1 파티션의 제약 사항
---
- Pk를 포함한 유니크 인덱스 는 파티션 키를 포함해야 한다.
- 파티션 개별로 인덱스를 변경하거나 추가할 수 없다.(로컬 인덱스)
- 모든 파티션은 동일한 스토리지 엔진을 사용
- 파티션 개수 8192개 제한
- 파티션 테이블에서 외래키 사용 불가
- 일부 내장함수는 파티션 프루닝 기능을 지원하지 않는다.


## 13.2.2 파티션 사용시 주의사항
---
- 파티션 의 목적은 작업 범위를 줄이는 것이다. 그러나 유니크 인덱스에 대한 제약 조건 때문에 항상 중복 레코드에 대한 체크 작업으로 범위가 좁혀지지 않는다.


### 13.2.2.1 파티션 과 유니크 키
- 유니크 키를 통해 해당 레코드가 어느 파티션에 있는지 계산할 수 있으면 파티션 생성이 가능하다.
```sql

create table tb_partition(
	fd1 int not null,
	fd2 int not null,
	fd3 int not null,
	unique key(fd1,fd2,fd3),
	unique key(f3)
) partition by hash (fd3)
partitions 4;
```


# 13.3 MySQL 파티션의 종류
- 레인지 파티션
- 리스트 파티션
- 해시 파티션
	- 리니어 파티션
- 키 파티션

## 13.3.1 레인지 파티션
---
- 연속된 범위로 파티션 정의, 가장 일반적인 방법
- 이력 데이터에 적용하는 것이 적합하다. (로그)
- `partition p0 values less than MAXVALUE` 를 사용해 파티션 범위에 없는 레코드들을 저장할 수 있다.
	- `...MAXVALUE` 파티션이 없을 때 정의한 범위 외의 값을 갖는 레코드 추가 시 에러 발생
- **파티션 추가**
	- `alter table employees add partition(partition p4 values less than(2011))`
	- 가장 마지막 파티션만 새로 추가가능
- **파티션 분리**
	- `... reorganize partition p3 into( partition p3 ..., partition p4)`
	- `reorganize partition` 은 읽기 잠금이 필요해 다른 트랜잭션의 처리를 방해한다.
- **파티션 삭제**
	- `alter table drop partition p0`
	- 가장 오래된 파티션 순서로만 삭제 가능
- **파티션 병합**
	- `reorganize partition p2, p3 into (partition p23 ...)`



## 13.3.2 리스트 파티션
---
- 파티션 키 값 하나하나를 리스트로 나열하며 아래와 같은 경우 사용에 적합하다.
	- 파티션 키 값이 **카테고리와 같이 고정적** 이거나 
	- 키 값이 **연속되지 않고** **정렬 순서가 상관 없을 때** 
	- 키 값을 기준으로 **레코드 건수가 균일**하고 **검색 조건에 파티션 키가 자주 사용될 때*
```sql

create table product(
...
	category_id int not null
) partition by list (category_id)(
	partition p_appliance values in (3),
	partition p_appliance values in (1,9),
	partition p_appliance values in (4,5,8,null),
)
```



## 13.3.3 해시 파티션
---
- **해시 함수** : 파티션 표현식의 결과 값 % 파티션 개수
- 따라서 **해시 파티션 키는 항상 정수** 값이 와야한다.
	- 특정 칼럼 값에 영향 받지 않고, 테이블 데이터를 균등하게 나눌 수 있다.
	- 테이블의 모든 레코드가 비슷한 사용 빈도를 갖지만 테이블이 너무 커 파티션이 필요할 때 **해시 파티션** 을 사용
```sql
partition by hash(id)
partitions 4
```
- 해시 파티션은 **추가 시** 전체 파티션을 대상으로 레코드를 **재분배** 하는 작업이 필요하다.
	- **파티션 수의 변경은 해시 함수가 변경되는 것이므로**
- 해시 파티션은 특정 파티션 **삭제, 분할 불가능** 
- 해시 파티션은 병합은 지원하지 않으며, **전체 파티션 개수중 일부를 줄일 수 만 있다.**
	- `alter table employees coalesce partition 1`
	- 파티션 개수 1개를 줄인다. 마찬가지로 레코드의 재배치가 필요하며 전체 레코드에 대해 리빌드 작업이 필요하다.

## 13.3.4 키 파티션
---
- 해시 파티션과 유사하나 정수 타입 뿐 아니라 대부분의 데이터 타입을 파티션 키로 사용 가능하다. 
- `partition key()` 와 같이 파티션 키를 생략하면 아래의 우선순위로 파티션 키를 자동으로 사용한다.
	- pk
	- unique key
- 프라이머리 키나 유니크 키의 일부만으로도 파티션 가능
- 해시 파티션 보다 더 균등하게 레코드를 분할할 수 있다.

## 13.3.5 리니어 해시 파티션/리니어 키 파티션
---
- **power-of-two** 알고리즘을 사용해 파티션을 분배, 통합한다.
	- 파티션 추가 시엔  특정 파티션에 대해서만 이동작업이 필요
	- 통합 시엔 통합되는 파티션만 레코드 이동이 필요
- **키/ 해시 파티션** 보다 작업 범위를 줄이지만, 레코드가 덜 균등하게 나타난다.


## 13.3.6 파티션 테이블의 쿼리 성능
---
- 파티션 프루닝이 사용되게 하는게 가장 중요하다.

```sql

create table user(
		id int not null
		,name varchar(20)
		,primary key(id)
		,index ix_name(name) )
	partition by key() partitions 1024; 
-- id 를 파티션 키로  자동 설정된다.

insert into user values(1,'todo')

explain
select * from user where name='todo'

```
- 위와 같은 쿼리는 1024 개의 파티션에 대해 `name` 인덱스를 스캔해야하므로 파티션을 설정 했음에도 성능에 악영향을 준다.
- 오히려 단일 테이블로 구성했을 때 B-Tree 를 한번만 룩업 하면 되므로 효율적이다.
