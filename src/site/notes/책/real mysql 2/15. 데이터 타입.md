---
{"dg-publish":true,"permalink":"//real-mysql-2/15/"}
---


```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false

```

# 15.1 문자열 (CHAR와 VARCHAR)
## 15.1.1 저장 공간
---
- `varchar` 타입은 가변 공간을 사용해 전체 길이를 저장하기위한 1~2Byte 의 오버헤드 가 필요하다.
- `char` 는 공간이 정해져 나머지 공간은 공백 문자로 채운다.
- `varchar` 의 경우 문자열을 `update` 할 때 특이사항이 있다.
	- `update` 할때 더 큰 길이의 값으로 변경하면 레코드를 다른 공간에 옮겨서 저장해야 한다.
- MySQL 에서 `varchar()` 에 들어가는 숫자는 문자 열의 길이를 의미한다. 다른 DB는 바이트 크기를 의미한다.



## 15.1.2 저장 공간과 스키마 변경(Online DDL)
---
- `varchar(60)` 인 칼럼을 `varchar(63)` 으로 변경하면 잠금 없이 빠르게 스키마를 변경 가능하다.
- 반면에 `varchar(64)` 로 변경하려면 `copy` 알고리즘과 읽기 잠금이 필요하다.
- 이는 `utf8mb64` 의 바이트가 4 바이트 인데, `varchar(63)` 은 254 바이트로 문자열의 길이를 저장할 때 1바이트로 충분하기 때문이다.
- 반면에, `varchar(64)` 는 문자열 길이를 저장하는 바이트를 2 바이트로 늘려주어야 한다.
- 문자열 길이 저장 공간을 변경할 때는 스키마를 변경하면서 아무도 데이터를 변경하지 못하도록 막고 테이블의 레코드를 복사해 처리해야 한다.


## 15.1.4 콜레이션
---
- 문자열 칼럼 값에 비교나 정렬 순서를 위한 규칙
- 모든 문자열 타입의 칼럼은 독립적인 문자열 집합, 콜레이션을 갖는다.
	- 다른 콜레이션을 갖는 두 칼럼의 조인은 성능 저하를 일으킨다.
- 문자열은 인코딩된 바이트 값에 해당하고 비교가 필요할 경우에 콜레이션 값으로 매칭한 후에 비교한다. 
	- 문자열이 저장된 바이트 값은 직접적인 비교 대상이 아니다.
- 문자열 칼럼은 `char`, `varchar` 같이 타입 이름과 길이만 같다 해서 서로 동일하다 판단해선 안되고, 문자 집합 (chracter set) 과 콜레이션 또한 일치 해야 동일 하다 판단할 수 있다.

## 15.1.5 비교 방식
---
- `varchar` 과 `char` 비교 시에 공백 문자를 뒤에 붙여 동일한 길이로 만든 후에 비교를 수행한다.
	- 문자열 앞의 공백의 차이는 동일하다 판단하지 않는다.
- `utf8mb4` 의 UCA 버전 9.0.0 (`utf8mb4_0900_XX`) 는 공백 문자 비교 방식이 다르다.
	- 문자열 뒤의 공백이 존재해도 동일하지 않다 판단한다.
	- `select 'a' = 'a '` 는 0 을 반환한다. (이전 버전에선 1 반환)
	- `pad_attribute` 의 값이 `no pad` 인 경우 공백을 채워 넣어 동일한 길이로 만들지 않고, 문자열을 있는 그대로 비교한다.
- `like` 연산의 경우 예외적으로 공백 문자를 유효 문자로 취급한다.
	- `select 'abc   ' like 'abc' ` 는 0 을 반환한다.


# 15.2 숫자
- 근삿 값 (부동 소수점)
	- `float`
	- `doulbe`
- 참 값 
	- `integer`
	- `demical`

- 표기 법으로 **이진 표기법**, **십진 표기법** 으로 분류 가능하다.
	- `demical` 타입만 **십진 표기법** 이며, 그 외는 모두 **이진 표기법**
	- **십집 표기법** 은 한 숫자를 표기하기 위해 4 비트나 한 바이트를 사용한다.


## 15.2.1 정수
---
- `tinyint`
- `smallint`
- `mediumint`
- `int`
- `bigint`
- 저장 가능한 숫자 값의 범위만 다르고 그외에는 거의 차이가 없다.
- `unsinged` 옵션을 통해 양수만 저장할 수 있는데, `unsinged` 와 `signed` 가 조인 되더라도 인덱스를 사용할 수 있다.



## 15.2.2 부동 소수점
---
- 부동 소수점은 근사 값을 저장하는 방식이여서 `equal` 비교를 할 수 없고, 크다 작다를 비교하기도 쉽지 않다.
- 부동 소수점을 사용해야 하는 경우 유효 소수점의 자릿수만큼 10을 곱한 후 정수 칼럼에 저장해 문제를 해결할 수 있다.


## 15.2.3 DEMICAL
---
- 고정 소수점 타입을 제공한다.
- 소수점 이하의 값을 정확하게 관리하기 위한 타입이다.
- 숫자 하나를 저장하는데 1/2 바이트가 필요하다.
- 정수 값을 저장할 땐 공간 효율이 나쁘므로 사용 x
- `demical(20,5)` 정수 15 자리, 소수 5 자리를 의미한다.
- `demical` 은 **저장 공간 크기가 가변적**이고, 그외의 정수 타입들은 **고정형 데이터 타입** 이다.
	- `bigint(10)` 과 같은 경우는 저장 공간 크기를 지정하는 것이 아닌, 화면에 표시할 자릿수를 의미한다.


# 15.3 날짜와 시간
- **날짜, 시간 타입 종류**
	- `year`
	- `date`
	- `time`
	- `datetime`
	- `timestamp` 
- `time, datetime, timestamp` 는 밀리초 단위를 저장할 수 있다. 밀리는 2자리당 1바이트 공간이 필요하다.
	- `datetime(6)` = 5 + 3 바이트의 저장 공간이 필요하다.
- `datetime`, `timestamp` 는 같은 역할을 하나, **UTC 타임존** 적용 유무의 차이가 존재한다.
	- `datetime` : `time_zone` 값에 대해 아무런 변환 처리 없이 저장된다. (커넥션 입력 값 그대로 저장)
	- `timestamp` : 커넥션의 `time_zone`에 알맞게 값이 저장된다.

- `system_time_zone` : 일반적으로 운영체제의 타임존을 상속 받는다.
- `time_zone` : `timestamp` 는 이 값에만 영향을 받는다. `time_zone` 값이 `SYSTEM` 이라면, `system_time_zone` 의 영향을 받게된다.

- `default current_timestamp`, `on update current_timestamp` 로 초기 값을 지정하고,  수정 시점을 자동으로 업데이트 할 수 있다.


# 15.4 ENUM 과 SET

- 내부적으로 숫자 값을 매핑 해서 관리한다.
## 15.4.2 ENUM
---
- 테이블 구조 (메타 데이터) 에 나열된 목록 중 하나를 값 으로 가진다.
- 실제 디스크에 저장될 때는 메타데이터에 매핑된 정숫값을 사용한다.
- `enum` 타입은 새로운 값을 추가할 때 테이블의 구조를 변경해야 한다는 단점 이 있다.
	- `enum` 타입 제일 마지막에 값을 추가하면 `instant` 알고리즘으로 변경 가능하다. (메타 데이터만 변경)
	- 그러나, 그 외의 위치에 새로운 값을 추가하면 전체 테이블을 `copy` 알고리즘 과 읽기 잠금이 필요하다.
- 정렬을 수행하면 매핑된 코드 (정숫값) 을 기준으로 정렬된다.
- **`enum` 타입의 장점은  정숫값을 저장 하기 때문에 디스크 저장 공간 크기가 줄어든다는 점이다.**
	- 디스크 저장 공간의 크기는 결국 버퍼 풀로 적재 되어야 하기 때문에 쿼리 성능에 영향을 준다.

## 15.4.2 SET
---
- `enum` 과 같은 방식으로 테이블의 구조에 정의된 아이템을 정숫값으로 매핑해 저장한다.
- 그러나, `set` 은 한 칼럼에 1개 이상의 값을 저장할 수 있다.

``` sql
select * from tb_set where find_in_set('golf',fd);
select * from tb_set wehre fd_set like '%golf%';
```
- 위와 같이 여러 세트가 저장 된 칼럼을 검색할 수 있다.
- 동등 비교 시엔  칼럼에 저장된 순서대로 문자열을 나열해야 한다.
- `set` 타입의 새로운 아이템을 추가하는 것 또한 `enum` 과 동일한데, 
	- 마지막에 추가하는 경우 메타데이터만 수정해 빠르게 처리되지만, 중간 위치에 새로운 아이템을 추가하면 읽기 잠금과 리빌드 작업이 필요하다. (copy, shared lock)

## 15.5 TEXT 와 BLOB
- 대량의 데이터를 저장할 때 사용된다.
- 다음과 같은 경우에 `text`, `blob` 타입을 사용한다.
	- 칼럼 하나에 저장되는 문자열이나 이진 값의 길이를 예측할 수 없을 때
	- 레코드의 전체 크기가 64KB 를 넘어서서 더 큰 칼럼을 추가할 수 없을 때, 일부 칼럼을 `text`,`blob` 타입으로 변경
- **저장 방식**
	- 저장 방식은 테이블의 `row_format` 옵션에 의해 결정된다.
	- `row_format` 의 값은 다음과 같다.
		- `redundant`
		- `compact` -> 다른 규칙들의 근간
		- `dynamic` -> MySQL5.7 이후부터의 기본 값
		- `compressed`
	- 레코드와 `text`,`blob` 을 **같은 위치 (프라이머리 키 페이지)에 저장하려고 노력**하나, 레코드 최대 길이 제한에 의해 불가능하다.
		- 레코드의 최대 길이를 초과 하면, `text`,`blob` **데이터는 외부 페이지에 저장**된다.
		- 외부 페이지로 저장될 때 `text`,`blob` 16KB 크기를 넘기는 경우 여러개의 외부 페이지로 저장하고 각 **페이지를 체인으로 연결한다**.


# 15.7 JSON 타입
- `jons` 타입은 원래는 `blob`,`text` 타입에 문자열로 저장되던 방식에서 **BSON(Binary JSON)** 형식으로 변환해 저장할 수 있게 해준다.

## 15.7.1 저장 방식
---
- `json` 타입은 저장될 때 **BSON** 으로 변환되어 내부적으로 `blob` 타입으로 저장된다.
- `json` 칼럼에 저장 될 때는 이진 데이터로 저장되는데, 모든 키에 대한 키와, 이름이 앞 쪽에 저장되고 그 뒤에 필드의 값이 저장된다.
	- 이러한 구조로, 특정 필드의 값만 업데이트, 참조할 때 `json` 칼럼의 값을 모두 읽어보지 않아도 즉시 원하는 필드의 이름을 읽거나 변경 할 수 있다. 
	- **부분 업데이트** 라 한다.
- `json` 또한 `blob` 과 같이 여러 데이터 페이지로 나뉘어 저장된다.
	- 부분 업데이트를 효율적으로 처리하기 위해선 링크드 리스트 (체인) 형태로는 불가능하다.
	- 그래서, `blob` 페이지들의 인덱스를 관리하고 각 인덱스를 페이지들을 링크 하는 방식을 사용한다.
	- `json` 의 부분 업데이트가 필요할 때, `blob` 페이지 인덱스와 `json` 칼럼의 각 필드의 주소 정보를 이용해 필요한 부분만 변경 가능 하다.

## 15.7.2 부분 업데이트 성능
---
```sql
update tb_json set fd = JSON_SET(fd, '$.user_id',"12345678901") where id =2;
```
- 정수 타입의 필드라면 항상 부분 업데이트가 적용 될 수 있다.
- 그러나 문자열 타입의 필드라면 저장 되는 문자열의 길이에 따라 부분 업데이트가 사용되지 못할 수 있다.
	- 10BYTE 의 공간을 가자는 기존 레코드를 위의 쿼리로 11BYTE 로 변경한다면, 최초 할당 했던 공간으로 부족하기 때문에 `json` 레코드를 통째로 복사해 다른 위치에 저장한다.
	- 즉 부분 업데이트를 사용 못할 수 있는데, 특정 필드의 용량이 자주 길이가 다른 값으로 변경된다면 다음과 같이 해결해야 한다.
		- 예상되는 최대 값으로 초기화 해두거나
		- 어플리케이션에서 패딩을 추가해 고정 길이 문자열로 만들어야 한다.


## 15.7.3 JSON 타입의 콜레이션 비교
---
- `json` 칼럼에서 나온 결과 값은 모두 `utf8mb4`와 `utfmb4_bin` 콜레이션을  갖는다.
- 따라서, 대소문자 구분 및 액센트 문자 등도 모두 구분해서 비교한다.


## 15.7.4 JSON 칼럼 선택
---
- 정규화된 테이블과 `json` 칼럼을 중 어떤 것을 선택해야 할지 고민 해보아야한다.

|        | 정규화된 칼럼                                         | JSON                                                                                              |
| ------ | ----------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| 칼럼명    | 칼럼의 이름을 메타 정보로만 저장, 데이터 파일의 공간 차이 x             | 필드 이름이 매번 데이터 파일에 저장되어야 한다.                                                                       |
| 저장 방식  | `blob`,`text` 같은 대용량 데이터의 경우 **외부 페이지로 관리** 된다. | 모든 데이터를 `json` 칼럼에 저장하기 때문에 필요한 데이터를 선별적으로 접근 할 수 없다. 정수 값을 하나 참조 하더라도 `json` **칼럼 전체를 읽어 봐야한다**. |
| 데이터 구조 | 정형 데이터 저장에 적합하다.                                | 비정형 데이터 저장에 적합하며, 중요도가 낮은 데이터에 사용하면 좋다. (검색조건에 사용이 드문)                                            |



# 15.8 카상 칼럼(파생 칼럼)
- 가상 칼럼은 기존 칼럼의 값을 계산해서 관리하는 **파생 칼럼** 이다
- 아래 두가지로 구분할 수 있다.
	- virtual column
	- stored column

| virtual column                                             | stored column                                             |
| ---------------------------------------------------------- | --------------------------------------------------------- |
| 칼럼 값이 디스크에 저장 x                                            | 칼럼 값이 **디스크에 저장**된다.                                      |
| 칼럼의 구조 변경이 테이블 리빌드 x                                       | 칼럼의 구조 변경이 테이블 리빌드 필요                                     |
| 레코드가 읽히기전 또는 before 트리거 **실행 직후에 계산되어 만들어 진다**.            | `insert`, `unpdate` 시점에 칼럼 값이 계산된다.                       |
| `total_price demical(10,2) as (quantity*price) as virtual` | `total_price demical(10,2) as (quantity*price) as stored` |
- 가상 칼럼은 조회 시점에 매번 계산되고 스토어드 칼럼은 저장 공간을 많이 차지한다.
- 즉, **cpu 사용량을 높여 다스크 부하를 낮출 것인지 아니면 디스크의 사용량을 높여 cpu 사용량을 낮출 것인지 선택**해야 한다.






