---
{"dg-publish":true,"permalink":"//jpa/8/"}
---


```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false
```

# 8.1 프록시
- **지연로딩 :** 프록시를 사용해 엔티티가 실제 사용될 때까지 데이터 베이스를 조회 하는 방법을 제공한다.

## 8.1.1 프록시 기초
---
- `em.getReference` 를 사용하면, jpa 는 데이터 베이스를 조회하지 않고 프록시 객체를 반환한다. 프록시 객체는 실제 객체가 사용되는 시점 까지 DB 조회를 미룬다.
#### 프록시 특징
- 프록시 객체는 처음 사용할 때 한번만 초기화 된다.
- 실제 클래스를 상속받아 만든다.
- 프록시 객체는 실제 객체에 대한 참조(target)를 보관한다.
- **프록시 객체의 메소드를 호출 하면 타겟의 메소드를 호출 한다.**
- 영속성 컨텍스트에 이미 엔티티가 존재하면 프록시가 아닌 실제 엔티티를 반환한다.
- **준영속 상태의 프록시를 초기화 하려하면 에러 발생**

#### 프록시 객체의 초기화
- 실제 데이터가 사용될 때 DB 를 조회해 실제 엔티티 객체를 생성하는 과정이다.


```java

class MemberProxy extends Member{
	Member target= null;
	public String foo (){
		if(target==null){
			//1. 초기화 요청
			//2. DB 조회
			//3. 실제 엔티티 생성 및 보관
			this.target= ...
		}
		return target.foo();
	}
}
```



## 8.1.2 프록시와 식별자
---
- 프록시는 엔티티의 식별자를 저장하고 있다. 따라서 식별자를 조회하더라도 프록시는 초기화되지 않는다.
- AccessType.PROPERTY 설정한 경우 `getId()` 식별자를 조회 시에는 DB접근을 안하기에 프록시를 초기화 하지 않는다.
- AccessType.FIELD 로 설정된 엔티티는 `getId()` 가 id만 조회하는 메소드인지 알 수 없기 때문에 시에 프록시 객체를 초기화한다.


>
>AccessType.FIELD 로 적용 후 `getId()`를 실행해  테스트 했을 때에도 프록시가 초기화 되지 않는다.
> **자바 빈 규약에 맞는 getXX 로 호출 했기 때문인데, 함수 명을 바꾸면 쿼리가 수행되며 객체가 초기화 된다.**

```java
  
@Test  
public void foo(){  
    MemberProxy reference = em.getReference(MemberProxy.class, 1L);  
    Long id = reference.getId(); // accesstype.field 여도 프록시가 초기화 되지 않음
    System.out.println("id = " + id);  
    Long id2 = reference.findId();  // findXX로 빈 규약에 맞지 않아 메서드가 어떤 일을 하는지 알지 못하므로 객체가 초기화 된다.
  
}
```


## 8.1.3 프록시 확인
--- 
- `PersistenceUnitUtil.isLoaded`  로 프록시가 초기화 되었는지 확인 가능하다.
- 초기화 되었거나, 프록시 인스턴스가 아니면 true


# 8.2 즉시 로딩과 지연 로딩
| 로딩 종류     | 함수                    | 비고                   |
| --------- | --------------------- | -------------------- |
| **즉시 로딩** | `FectchType.EAGER`    | 연관 객체를 함께 조회한다.      |
| **지연 로딩** | `FectchType.LAZY`<br> | 연관 객체를 사용 시점에 조회 한다. |


## 8.2.1 즉시 로딩
---
- **jpa** 는 즉시 로딩 시에 연관 객체를 모두 DB 로 부터 가져온다.
- **이때, jpa 는 select 문이 2번 수행되지 않고 join 쿼리를 실행해 쿼리를 최적화 한다.**


## 8.2.2 지연 로딩
---
- 연관 객체를 불러올 때 프록시 객체를 반환한다. 프록시 객체는 앞서 보았듯 실제 사용할 때 초기화 된다. 
- 프록시의 이러한 특성을 활용하는 것을 **지연 로딩**이라한다.
- 지연 로딩은 조인 쿼리를 수행하지 않고 쿼리를 두번 수행한다.
- **프록시 객체가 이미 영속성 엔티티에 존재한다면 프록시가 아닌 실제 객체를 반환한다.**




# 8.3 지연 로딩 활용
## 8.3.1 프록시와 컬렉션 래퍼
---
- **컬렉션 래퍼** : 하이버네이트에서 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 **컬렉션 래퍼** 로 변경한다. `PersitentBag`
- 엔티티는 프록시 객체가 지연 로딩을 수행하게끔 해주고, 컬렉션은 **컬렉션 래퍼가** 이를 담당한다.


## 8.3.2 JPA 기본 페치 전략
---
- @ManyToOne, @OneToOne 즉시 로딩
- @OneToMany, @ManyToMany 지연 로딩
- **연관 엔티티가 컬렉션인 경우에 지연 로딩을 기본값으로 사용한다.**
- **모든 연관 관계를 지연로딩으로 설정하고 필요에따라  즉시 로딩으로 최적화하는 방법을 권장한다.**


## 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점
---
- **컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.**
	- 테이블 여러개 조인 해야하므로 너무 많은 데이터를 반환하게 되는데, JPA는 조회 결과를 메모리상에서 필터링을 수행하기 때문에 성능에 문제가 생긴다.
 >`A join B join C` 같은 쿼리가 실행될 수 있다.  A가 B, C 테이블과 1:N 관계 존재할 때, B 테이블에 같은 a_id 를 갖는 레코드 n 개와 C 테이블에 같은 a_id 를 갖는 레코드 m 개를 곱한 결과 만큼 데이터가 조회된다. 

 

- **컬렉션 즉시 로딩은 항상 외부 조인을 사용한다.**
	- Team, Member 의 연관 테이블이 존재할 떄, Member 에 특정 Team 레코드와 참조관계가 없을 수 있다. 내부 조인을 사용하게 되면 연관 관계가 없는 Team 레코드가 조회되지 않으므로 항상 외부 조인을 사용한다.
		- `@OneToOne(mappedBy = "parent",fetch = FetchType.EAGER, optional = false)`
		- `@JoinColumn(name="parent_id", nullalbe=false)` 
	- 위 같이 설정하여 항상 연관관계가 성립함을 보장해 `left outer join` 을 `inner join` 으로 개선할 수 있다.




# 8.4 영속성 전이: CASCADE
- **특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들어 준다.**
## 8.4.1 영속성 전이: 저장
---
- `cascade = CascadeType.PERSIST` 로 영속성 전이를 사용할 수 있다.
- 부모 엔티티가 영속화 될 때 자식 엔티티 까지 함께 영속화 된다.
> 테스트 결과 자식 엔티티에 `cascade = CascadeType.PERSIST` 를 작성해주었을 경우에도 동일하게 동작한다. 자식 엔티티를 영속화할 때 부모엔티티도 영속화 된다.


## 8.4.2 영속성 전이: 삭제
---
- 영속성 전이는 삭제할 때도 사용 가능하다. `CascadeType.REMOVE` 로 설정하면 자식 엔티티도 함께 삭제된다.



# 8.5 고아 객체
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제한다.
- 부모 엔티티 컬렉션에서 자식을 제거해 자식 엔티티를 자동으로 삭제할 수 있다.
- **자식 엔티티가 참조하는 부모 엔티티가 한개일때만 사용해야한다.**
  부모 엔티티를 기준으로 자식 엔티티를 삭제하기 때문에 자식 엔티티가 여러 참조 관계를 맺고 있다면 원하지 않는 삭제 쿼리가 실행될 수 있다.

# 8.6 영속성 전이 + 고아객체, 생명주기
- `CascadeType.ALL` + `orphanRemoval=true` 를 동시에 쓰면, **자식 엔티티의 생명주기를 모두 부모 엔티티를 통해서 관리할 수 있다**.
- 두 속성을 부모 객체에 적용했다 가정한다면, `CascadType.ALL` 로 인해 부모 객체와 자식 엔티티의 생성, 삭제를 동시에 할 수 있다. `orphanRemoval=true` 로 인해 부모객체에서 참조관계를 제거함으로써 자식 객체를 삭제할 수 있다.

> **cascadeType.REMOVE** 과 **orphanRemoval** 의 차이점은 전자는 자식 객체의 연관 관계에서도 사용할 수 있지만, 후자는 그렇지 않다.
> 또, **orphanRemoval** 은 부모 객체에서 연관관계를 끊으면 자식 엔티티가 삭제되는 반면 **cascadeType.REMOVE** 는 엔티티가 제거될 때에 연관 관계의 엔티티 또한 함께 제거되는 옵션이다.
> 













