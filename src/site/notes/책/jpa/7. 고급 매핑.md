---
{"dg-publish":true,"permalink":"//jpa/7/"}
---


```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false

```
# 7.1 상속관계 매핑
- RDB 는 상속의 개념이 없어 객체의 상속을 구현하기 위해 **슈퍼타입 서브타입 관계** 모델링 기법을 사용한다.

## 7.1.1 조인 전략
---
- 서브타입 테이블의 기본키를 슈퍼타입의 기본키를 받아 사용한다. 또 기본키를 외래키로 사용해 조인에 사용한다.
- 슈퍼타입 테이블의 **Dtype** 으로 어떤 서브타입 테이블인지 식별한다.
- `@Inheritance(strategy=InheritanceType.JOINED)`
- 테이블이 정규화되고, 저장공간이 효율적이다.
- 그러나, 조인을 사용하는 만큼 성능이 비교적 느리고 insert 시에 슈퍼 타입, 서브 타입에 한번씩 두번 쿼리를 수행해야한다.


## 7.1.2 단일 테이블 전략
---
- `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` 
- 서브타입들의 모든 칼럼이 하나의 테이블에 저장된다.
- 따라서, null 을 허용해야 한다.
- 조인이 필요하지 않고 한번의 insert 만 필요해 성능이 가장 빠르다.
- **테이블이 과도하게 커져 오히려 성능이 저하될 수 있다.**

## 7.1.3 구현 클래스마다 테이블 전략
---
- `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` 
- 자식 엔티티마다 테이블을 만든다.
- **Union** 쿼리를 수행해야해 여러 자식 테이블을 함께 조회할 때 성능이 나쁘다.
- 자식 테이블을 통합해서 관리해야 할 경우 쿼리가 어렵다.
- 안티 패턴이므로 **조인 전략, 단일 테이블 전략**을 사용해야 한다.



# 7.2 @MappedSuperclass
- `@MappedSuperclass` 는 실제 테이블과 매핑 되지 않고 **정보를 자식 테이블에 상속할 목적**으로 사용한다.

> InheritanceType.TABLE_PER_CLASS 과 같은 테이블을 생성한다. 차이점은 @MappedSuperclass 등록일자, 생성자, 수정자와 같이 여러 엔티티에서 공통으로 사용되는 속성을 관리하는데 사용된다. 
> InheritanceType.TABLE_PER_CLASS 는 슈퍼 타입과 서브 타입 간의 관계를 나타낼 때 사용된다.



# 7.3 복합 키와 식별 관계 매핑
## 7.3.1 식별 관계 vs 비식별 관계
---
- **식별 관계** : 기본 키 + 외래 키로 기본키 사용
- **비식별 관계** : 부모 테이블의 기본 키를 외래 키로만 사용

## 7.3.2 복합 키 : 비식별 관계 매핑
---
- jpa 에서 엔티티를 보관시 식별자를 키로 사용한다.
- 또, 식별자를 구분하기 위해 `equals, hashCode` 를 사용해 **동등성** 비교를 한다.
- **@EmbeddedId,@IdClass** 두 방식으로 구현 가능하다.


## 7.3.3 복합 키 : 식별 관계 매핑
---
- **@EmbeddedId,@IdClass** 두 방식으로 구현 가능
- @EmbeddedId 사용 시에 **@MapsId** 로 @Embeddable 에 선언한 변수에 매핑된다.


## 7.3.4 비식별 관계로 구현
---
- 복합 키 클래스를 따로 생성하지 않아도 되서 코드가 쉽고 단순하다.


## 7.3.5 일대일 식별 관계
---
```java
public class BoardDetail {
	@Id
	private Long boardId;
	
	@MapsId //값을 생략하면 @id 식별자와 매핑된다.
	@OneToOne
	@JoinColumn(name="board_id")
	private Board board;

}
```


## 7.3.6 식별, 비식별 관계의 장단점
---
- 식별 관계 사용 시에 식별 관계의 계층이 많아지면 기본키가 점점 늘어나 sql 이 복잡해지는 단점이 있다.
- **자연키**를 사용하는 **식별 관계**는 비즈니스가 변함에 따라 자식 테이블들에도 전파되어 변경하기가 힘들다.
- **식별 관계** 를 사용하면 기본 키 인덱스를 사용하기 좋고 상위테이블의 기본키로 자식 테이블들을 조인 없이 검색할 수 있다. **커버링 인덱스가 가능해진다.**
- **Long 타입의 비식별 관계를 사용하는 것이 좋다.**
- **선택적 비식별 관계** 보다는 **필수적 비식별 관계** 를 사용해야한다.
- **필수적 비식별 관계는** `not null` 조건을 사용해 내부 조인을 이용한다. 
  *부모 엔티티가 존재하지 않으면 자식 엔티티가 존재할 수 없기 때문이다.*
-  그러나 **선택적 비식별 관계** 는 `null` 조건을 사용해 외부 조인을 사용한다.
  *부모 엔티티가 존재하지 않아도 자식 엔티티가 존재할 수 있기 때문이다.*


# 7.4 조인 테이블

- `@JoinTable` 을 사용해 외래키가 아닌 테이블로 연관관계를 매핑한다.
- 조인 테이블을 사용하면 조인 테이블을 추가하고 여기서 두 외래키를 관리한다.
- 두 테이블 간 의존성이 적어 연관 관계를 매핑하고 싶을 때 매핑할 수 있다는 장점이 있다.
- 그러나, 테이블을 추가해야하고 조인할 테이블이 증가한다는 단점이 있다.

