---
{"dg-publish":true,"permalink":"//jpa/13/"}
---



```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false

```

# 13.1 트랜잭션 범위의 영속성 컨텍스트

## 13.1.1 스프링 컨테이너의 기본 전략

![영속성 컨텍스트 생존 범위.png](/img/user/images/영속성-컨텍스트-생존-범위.png)

- 스프링 컨테이너는 **트랜잭션 과 영속성 컨텍스트가 같은 생명 주기를 공유하는 트랜잭션 범위의 영속성 컨텍스트 전략**을 기본으로 사용한다. 
- **실행 흐름**
	- `@service` 에서 `@Transactional` 을 실행하면 AOP 가 먼저 실행되어 트랜잭션을 시작한다.
	- 이때부터 영속성 컨텍스트가 존재해 엔티티들을 영속화한다.
	- 서비스가 종료되고 트랜잭션이 종료될 때, 영속성 컨텍스트 또한 종료된다.
	- 영속성 컨텍스트가 종료됐기때문에 `@Controller` 로 반환되는 엔티티는 준영속 상태의 엔티티이다.
- **트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다**.
	- `@service` 에서 여러 `@repository` 를 사용하고 엔티티 매니저를 주입 받아 사용하는데, 같은 트랜잭션이므로 영속성 컨텍스트 또한 공유한다.

- **트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.**
	- 멀티 스레드 환경에서 같은 엔티티 매니저를 사용하더라도 **트랜잭션이 다른 경우 접근 가능한 영속성 컨텍스트**가 다르다.
	- *스프링 컨테이너는 스레드마다 다른 트랜잭션을 할당한다.*


## 13.2 준영속 상태와 지연 로딩
- 영속성 컨텍스트는 트랜잭션 생명 주기와 동일하므로 `@Controller` 에서는 엔티티들이 준영속 상태로 존재한다.
- **변경 감지**와 **지연 로딩**는 영속성 컨텍스트에서 관리되는 엔티티를 대상으로 동작하므로 컨트롤러에서  이를 활용하려 해도 동작하지 않는다.
- **프리젠테이션** 계층에서도 영속성 컨텍스트를 사용하려면 어플리케이션 계층 가지는 책임이 모호해진다.
- **준영속 상태와 지연로딩**
	- 지연로딩된 객체를 사용하면 proxy 객체를 사용하게된다. 프리젠테이션 계층에서는 영속성 컨텍스트가 존재하지 않으므로 지연 로딩 시도 시에 `LazyInitializationException` 이 발생한다.
		- **해결 법**
			- 뷰가 필요한 엔티티를 미리 로딩 해둔다.
				- 글로벌 페치 전략 수정
				- JPQL 페치 조인
				- 강제로 초기화
			- OSIV 를 사용해 엔티티를 항상 영속 상태로 유지한다.

## 13.2.1 글로벌 페치 전략 수정
---
- `FetchType.EAGER` 로 설정해 즉시 로딩으로 변경한다.
- 즉시 로딩시 아래 두가지 단점이 존재한다.
#### 사용하지 않는 엔티티를 로딩한다.
- 화면 A 에서는 즉시 로딩이 필요하지만 다른 화면에서는 즉시 로딩이 필요하지 않은 경우 사용하지도 않는 엔티티를 조회하게 된다.
#### N+1 문제가 발생한다.
- **N+1 문제** 
	- `em.find()` 시 즉시 로딩 전략이면 JOIN 쿼리를 사용한다.
	- 그러나 `select o from order o` 와 같이 JPQL 을 사용하면 JOIN 생성하지 않고 JPQL 쿼리 자체를 수행한다.
	- 이후에 연관된 엔티티가 영속성 컨텍스트에 없다면, `select o from order o` 의 결과 수 만큼 연관 엔티티를 조회하는 쿼리를 실행한다.
## 13.2.2 JPQL 페치 조인
---
- `select o from order o join fetch o.member` 를 사용해 페치 조인 대상까지 함께 조회할 수 있다.
- **단점**
	- 화면에 맞춘 리포지토리 메소드가 계속 증가한다.
	- 프레젠테이션 계층이 데이터 접근 계층 간에 의존 관계가 생긴다.


## 13.2.3 강제로 초기화
---
- 영속성 컨텍스트가 살아있을 때 엔티티를 강제로 초기화해서 반환한다.
```java
//Order 과 Member 는 지연 로딩 관계이다.
    Order order =orderRepo.findById(1L); //프록시 반환
    order.getMember().getName(); // 강제 초기화
```
- 이미 초기화 했으므로 준영속 상태에서도 사용 가능하다.
- `Hibernate.initialize()` 메소드로 프록시를 강제 초기화할 수도 있다.
- `emf.getPersistenceUnitUtil().isLoaded()`로 프록시 초기화 여부를 확인할 수 있다.
- 서비스 계층의 코드가 프레젠테이션 계층의 코드에 종속적이게 된다.


## 13.2.4 FACADE 계층 추가
---
- 프리젠테이션 계층에서 사용되는 연관 엔티티를 서비스 계층에서 강제로 초기화하면 의존 관계가 생기게 되고 역할의 구분이 불분명 해진다.
- 그래서 프리젠테이션 계층과 서비스 계층 사이에 FACADE 계층을 두어 역할을 분리할 수 있다.
- FACADE 계층에서 프리젠테이션 계층을 위한 프록시 객체 초기화 작업을 하므로 트랜잭션이 여기서 시작되어야 한다.
- **FACADE 계층 추가는 계층이 추가되고 거의 위임하는 코드로 구성되기 때문에 실용적이지 못하다.**


# 13.3 OSIV
- **Open Session In view** 로 영속성 컨텍스트를 뷰까지 열어 두어 뷰에서도 **지연 로딩**이 가능하게 한다.


## 13.3.1 과거 OSIV: 요청당 트랜잭션
---
- 필터나 인터셉터에서 트랜잭션을 시작하고 종료하는 방식이 요청당 트랜잭션 방식의 OSIV 이다.
- **이 방식은 컨트롤러나 뷰 계층에서도 엔티티를 변경할 수 있는 문제가 존재한다.**

## 13.3.2 스프링 OSIV: 비즈니스 계층 트랜잭션
---

- 요청이 들어오면 영속성 컨텍스트를 (filter, interceptor) 생성한다. 
- 서비스 계층에서 트랜잭션이 시작하면 앞서 만들어둔 영속성 컨텍스트를 사용한다.
- 트랜잭션이 종료되어 commit 하는 시점에는 flush 만 수행하고 영속성 컨텍스트는 여전히 살려둔다.
- 클라이언트 요청이 끝날 때 영속성 컨텍스트를 종료한다.

#### 트랜잭션 없이 읽기
- 영속성 컨텍스트의 모든 변경은 **트랜잭션 안**에서 이루어져야 한다.
- **지연 로딩을 포함하여 단순히 엔티티를 읽는 경우에는 트랜잭션이 없어도 가능하다**.

| 영속성 컨텍스트 | 트랜잭션 | 동작     |
| -------- | ---- | ------ |
| O        | X    | 조회     |
| O        | O    | 조회, 수정 |
- 스프링 OSIV 는 트랜잭션이 시작되는 서비스 계층 이전(필터, 인터셉터)에 영속성 컨텍스트를 생성하므로 프리젠테이션 계층에서는 영속성 컨텍스트가 존재하고 트랜잭션은 존재하지 않는다. 따라서 엔티티를 자유롭게 조회하고 수정에 안전할 수 있다.

#### 스프링 OSIV 주의 사항
- 프리젠테이션 계층에서 영속 상태의 엔티티를 수정한 이후 또다른 트랜잭션을 수행하면 문제가 발생한다.
- 또 다른 트랜잭션이 종료될 때 영속성 컨텍스트를 flush 하기 떄문이다.
- **트랜잭션이 있는 비즈니스 로직을 모두 실행한 후에 엔티티 값을 변경하도록 해야 한다.**

















