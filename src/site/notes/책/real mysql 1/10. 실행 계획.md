---
{"dg-publish":true,"permalink":"//real-mysql-1/10/"}
---



```table-of-contents

style: nestedList

minLevel: 0

maxLevel: 0

includeLinks: true

debugInConsole: false

```

- 옵티마이저가 항상 쿼리를 최적으로 수행할 수 없기에 `explain` 으로 실행 계획을 확인 할 수 있다.

# 10.1 통계 정보

- **테이블 및 인덱스에 대한 정보**로 실행 계획을 수행 했는데, 8.0 버전 부터는 인덱스 되지 않는 칼럼들에 대해서 데이터 분포를 수집해서 저장하는 **히스토그램** 정보를 도입 했다.

## 10.1.1 테이블 및 인덱스 통계 정보
---
- 통계 정보를 이용해 비용 기반 최적화를 수행한다.

#### MySQL 서버의 통계 정보
[참고] : [[메모/DB/MySql 통계 정보 확인중 not found 문제\|MySql 통계 정보 확인중 not found 문제]]
- 5.6 버전 이전에는 통계 정보를 메모리에 저장해 휘발성이었으나 5.6 버전부터 테이블에서 관리하기 시작했다.
- `innodb_index_stats, innodb_table_stats` 테이블에서 통계 정보를 확인할 수 있다.
- MySQL 은 테이블이 새로 생성되거나, 대량의 레코드가 변경 `insert,delete` `analyze table` 실행 시에 자동으로 통계 정보를 변경한다.
- 통계 정보가 갱신 되면 쿼리가 인덱스 레인지 스캔으로 잘 실행되던 도중 갑자기 **풀 테이블 스캔**을 실행할 수 있다.

| innodb_stats_auto_recal 값 | 설명                                |
| ------------------------- | --------------------------------- |
| on                        | 기본값, 통계정보를 자동으로 수집                |
| off                       | 영구적인 통계 정보를 사용, 통계 정보 자동 갱신을 막는다. |

- 테이블 통계 정보를 수집할 때 몇개의 테이블 블록( 페이지 )을 샘플링할지 결정할 수 있다.
	- **innodb_stats_transient_sample_pages** : 자동으로 통계 정보 수집 시 임의의 페이지 수만 샘플링해 분석한다.
	- **innodb_stats_persistent_sample_pages** : `analyze table` 명령어 실행시 샘플링할 페이지의 수를 결정한다.
	  *innodb_status_auto_recal = off 일때, DB 사용량이 적은 시간대에 높은 값을 설정해 정확한 통계 정보를 수집 할 수 있다.*


## 10.1.2 히스토그램
---
- 5.7 이전 버전까지 인덱스된 칼럼의 유니크한 값의 개수로 통계 정보를 가지고 있었다.
- 최적의 실행 계획을 세우기에 부족함을 느껴 이후에 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다.
- 8.0 버전부터는 칼럼의 **데이터 분포도**를 참조할 수 있는 **히스토그램**을 사용한다.
#### 히스토그램 정보 수집 및 삭제
- 칼럼 단위로 관리 된다.
- 자동으로 수집되지 않고 `ANAYLIZE TABLE ... UPDATE HISTOGRAM` 명렁어로 수동으로 수집 및 관리 된다.
- 히스토그램은  **시스템 딕셔너리** 에 저장된다.
- MySQL 실행 시에 **시스템 딕셔너리**에서 **information_schema.column_statistics** 테이블로 로드된다.
- **히스토그램**
	- **싱글톤 히스토그램** : 칼럼이 가지는 값 별로 버킷이 할당
	- **높이 균형 히스토그램** : 개수가 균등한 칼럼 값의 범위 별로 하나의 버킷 할당
- 히스토그램 삭제 작업은 **시스템 딕셔너리의** 내용만 삭제하면 되므로 다른 처리 성능에 영향을 주지 않고 즉시 완료된다.
- 단, 히스토그램을 참조해 실행되던 쿼리들의 실행 계획이 변경될 수 있다.
- `optimizer_switch` 시스템 변수로 히스토그램 사용 유무를 설정할 수 있다.


#### 히스토그램의 용도
- MySQL 에 **히스토그램이 도입되기 전에는 쿼리에서 예측하는 칼럼의 유니크한 값의 개수가 모두 동등할거라 예측**하고 수행했다.
- 그러나, 실제 데이터는 항상 균등한 분포도를 가지고 있지 않아 정확한 예측을 할 수 없었다.
- 히스토그램은 칼럼이 가지는 값들의 정확한 분포도 정보를 저장하지 않지만 훨씬 정확하게 예측 가능했다.
- **히스토그램이 테이블에 존재하지 않으면 앞서 설명한대로 옵티마이저는 데이터가 균등하게 분포되어 있을 것으로 예측**한다.
- **인덱스 되지 않은 컬럼을 조건절로 사용하게 되면 히스토그램을 사용**한다. 히스토 그램 또한 존재하지 않는다면, 옵티마이저는 테이블의 전체 크기, 레코드 건수와 같은 정보를 가지고 드라이빙 테이블을 선택한다.


#### 히스토그램과 인덱스 
- 옵티마이저는 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
- **인덱스 다이브** : 조건절에 일치하는 레코드 건수를 예측하기 위해 실제 인덱스의 B-TREE를 샘플링해 보는 작업
- 인덱스된 칼럼을 검색 조건으로 사용하면 **인덱스 다이브**를 통해 직접 수집한 정보를 활용한다. 실제 검색 조건 대상 값에 대한 샘플링을 수행하므로 히스토그램 보다 정확한 결과를 얻을 수 때문이다.
- 히스토그램은 인덱스가 없는 칼럼에 대한 데이터 분포도를 참조할 때 사용한다.



## 10.1.3 코스트 모델 
---
- **서버가 쿼리를 처리하기 위해 수행하는 작업**
	- 디스크로부터 데이터 페이지 읽기
	- 버퍼풀로부터 데이터 페이지 읽기
	- 인덱스 키 비교
	- 레코드 평가
	- 메모리 임시 테이블 작업
	- 디스크 임시 테이블 작업
- MySQL 서버는 이러한 다양한 작업에 대해 비용을 예측하고 계산한 결과를 바탕으로 실행계획을 찾는다.
- **코스트 모델** : 실행 계획을 위해 비용을 계산할 때 사용하는 각 작업 단위 별 비용
- **설정가능한 작업 단위 비용**  
	- **io_block_read_cost** :
	  버퍼풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용할 가능성이 높아진다.
	- **memory_block_read_cost** :
	  버퍼 풀에 적재된 데이터 페이지가 상대적으로 적더라도 그 인덱스를 사용할 가능성이 높아진다.
	- **disk_temptable_create_cost, memory_temptabl_create_cost** :
	  이 값이 높아지면 임시 테이블을 만들지 않을 가능성이 커진다.
	- disk_temptable_read_cost, memory_temptable_read_cost
	- **key_compare_cost** :
	  키 값을 비교 하는 작업에 필요한 비용으로, 값이 높아지면 정렬과 같이 레코드 값을 비교해야하는 작업의 쿼리의 비용이 높아진다.
	- **row_evaluate_cost** :
	  스토리지 엔진이 반환 하는 레코드가 조건에 일치하는지 평가하는 단위로, 값이 증가할수록 **풀 테이블 스캔**의 비용이 높아지고 **인덱스 레인지 스캔과** 같이 레코드 처리량이 적은 쿼리의 비용이 낮아진다.
	  즉, 이 값을 높이면 **인덱스 레인지 스캔**할 가능성이 커진다.


# 10.3 실행 계획 분석

## 10.3.1 id 칼럼
---
- `select` 쿼리별로 부여되는 식별자 값이다.
- 여러 테이블이 조인되는 경우에는 id 값이 증가하지 않고 하나의 값을 사용한다.
- id의 값은 테이블 접근 순서를 나타내지 않는다.
- 테이블 접근 순서를 확인하려면 `explain format = tree ` 를 확인해야 한다.
## 10.3.2 select_type 칼럼
---
- 각 단위 `select` 쿼리가 어떤 타입의 쿼리인지 표시된다.
- 아래의 값들이 select_type 값으로 사용가능하다.
#### SIMPLE
- `union`, 서브쿼리를 사용하지 않는 단순한 `select` 쿼리
- 복잡한 조인문에서도 simple 인 쿼리는 단 하나만 존재한다.

#### PRIMARY
- `union`, 서브쿼리를 가지는 `select` 쿼리에서 가장 바깥쪽에 있는 단위 쿼리는 primary 값을 가지며, `select` 단위 쿼리에서 단 하나만 존재한다.

#### UNION
- `union` 으로 결합하는 단위 `select` 쿼리 가운데 두 번째 이후 단위 `select`쿼리는 union 값을 갖는다.
- 첫 번째 `select` 쿼리는 **derived** 값을 갖는다.

#### DEPENDENT UNION
- `union, union all` 을 사용하는 쿼리에서 단위 쿼리가 외부 쿼리에 영향을 받는 경우 사용된다.

#### UNION RESULT
- UNION 결과를 담아두는 테이블
- `union(union distinct)` 는 임시 테이블에 결과를 버퍼링하지만,  `union all` 의 경우 임시 테이블을 사용하지 않는다.
- 임시 테이블은 실제 단위 쿼리가 아니므로 id 값은 부여되지 않는다.

#### SUBQUERY
- From 절에 이외에 사용되는 서브쿼리를 의미한다.
- From 절의 서브쿼리는  select_type 값으로 **DERIVERD (파생 테이블)** 를 갖는다.

>**Nested Query** : `select` 되는 칼럼에 사용되는 서브쿼리
>**SubQuery** : `where` 절에 사용되는 서브쿼리
>**Derived Table** : `from` 절에 사용된 서브쿼리, inline view, sub select 라고도 부른다.


#### DEPENDENT SUBQUERY
- 서브쿼리가 Outer select 쿼리에 정의된 칼럼을 사용하는 경우 이 값을 갖는다.
- inner query 가 outer query 의 칼럼에 의존적이기 때문
- **외부쿼리가 먼저 실행된 이후에 내부 쿼리가 실행되야 하므로 일반 서브 쿼리보다 처리속도가 느릴 수 있다.**

#### DERIVED
- 단위 `select` 쿼리 결과를 메모리나 디스크에 임시 테이블로 생성하는 경우이다.
- `from` 절의 서브쿼리를 임시 테이블로 만들어서 처리한다.
- **조인 쿼리에 대한 최적화가 더 잘되어있으므로 임시 테이블을 생성하는 방식 (from 절에 서브쿼리 )보다 조인 쿼리를 사용해야한다.**


#### DEPENDENT DERIVED
- **LATERAL JOIN** 기능이 추가되면서 `from` 절의 서브 쿼리에서도 외부 칼럼 값을 참조할 수 있게 되었다. **dependent derived**는 `lateral` 사용시 select_type 칼럼의 값이다.
#### UNCACHEABLE SUBQUERY
- 하나의 쿼리 문장에 서브쿼리가 하나만 있더라고 그 서브쿼리는 한번만 실행되지 않는다.
- 조건이 똑같은 서브쿼리가 실행될 때 서브쿼리를 다시 실행하지 않고 이전의 실행결과를 캐시해두고 사용한다. 캐시하는 공간은 쿼리 캐시나 파생 테이블에 저장되지 않고 내부적인 다른 공간에 저장된다.
	- **SUBQUERY** : 바깥 서브쿼리에 의존하지 않으므로 한번만 실행해서 그 결과를 캐싱 한다.
	- **DEPENDENT SUBQUERY** : 바깥 서브쿼리의 칼럼의 값 단위로 캐시해두고 사용한다.
- 캐시를 사용하지 못하는 경우에 **uncacheable subquery** 을 칼럼 값으로 갖는다. 아래의 경우 캐시를 사용하지 못한다.
	- 사용자 변수가 사용되는 경우
	- NON-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용되는 경우
	- `UUID(), RAND()` 와 같이 결과 값이 호출마다 바뀌는 경우


#### UNCACHEABLE UNION
- UNION과 동일하지만 공급되는 모든 값에 대하여 UNION Query를 재처리, 캐시 사용 불가


#### MATERIALIZED
- `from` 절 혹은 `in` 형태의 쿼리에 사용된 서브쿼리를 **최적화**할 때 사용
- 서브쿼리의 내용을 임시 테이블로 구체화 (materialized)한 후 임시테이블과 employees 테이블을 조인해 최적화 한다.



## 10.3.3 table 칼럼
---
- 실행 계획은 단위 `select` 쿼리 기준이 아닌 테이블 기준으로 표시된다.
-  <derived N\>, <union M,N\> 과 같이 **"<>"** 로 둘러 싸인 값은 **임시 테이블**을 의미한다.
- 실행 계획에서 같은 id 값을 갖는다면 위에 있는 라인이 먼저 실행된다.
- table 값이 \<derived N\> 이라면 n 번째 라인이 먼저 실행돼 파생 테이블이 생성된다.


## 10.3.4 partiions 칼럼
---
- **partion prooning** : 쿼리에서 불필요한 파티션을 제외하고 접근해야 할 것으로 판단되는 테이블만 골라내는 과정
- 쿼리의 실행 계획에서 어느 파티션을 읽는지 **partitions** 칼럼에 표시해준다.
- rdbs 에서 파티션 테이블은 물리적으로 다른 테이블에 저장되어 풀테이블 스캔을 하더라도 모든 파티션이 아닌 조건에 충족하는 파티션만 풀 스캔을 실행하게 된다.


## 10.3.5 type 칼럼
---
- 쿼리 실행계획에서 테이블의 레코드를 어떤 방식으로 읽었는지 표시한다.
- ALL 제외한 모든 type 은 index 를 사용한다.
- ALL 은 풀 테이블 스캔을 의미한다.
- index_merge 를 제외한 값들은 인덱스를 하나만 사용한다.
- *이어 나오는 type 칼럼 값들의 설명은 쿼리 성능이 좋은 순서대로 나열된다.*

#### system
- 레코드가 1건 혹은 존재하지 않는 테이블을 참조하는 접근 방식
- InnoDB 테이블이 아닌 MyISAM, MEMORY 테이블만 적용

#### const

[참고] : [[책/real mysql 1/8. 인덱스#8.9 유니크 인덱스\|8. 인덱스#8.9 유니크 인덱스]]
- 레코드 건수와 관계 없이 쿼리가 **프라이머리 키**, **유니크 키 칼럼**을 where 조건절로 가지며, 반드시 1건을 반환하는 쿼리
- **unique index scan** 이라고도 한다.
- **MySQL 옵티마이저가 쿼리를 최적화 하는 단계에서 쿼리를  먼저 실행해서 통째로 상수화 시킨다.**


```sql

select * from table where id=1;
```


 - pk 나 unique_key 가 다중 칼럼일 때에는 모든 칼럼을 where 절에 명시해야 const 접근 방법을 사용한다. 
 - 모든 칼럼을 명시하지 않으면 ref 접근 방법 사용
``` sql
select * from table where idx1 =1 and idx2 = 2;
```


####  eq_ref
- 여러 테이블이 조인되는 쿼리에서 **드리븐 테이블의** **pk, unique_key(not null 포함)** 칼럼이 검색 조건에 사용될 때 사용될 때 **eq_ref** 로 표시된다.
- 다중 칼럼으로 만들어진 pk, unique_index 는 모든 칼럼이 비교 조건에 사용되어야 한다.
- **드리븐 테이블에서 읽어오는 칼럼 값이 const 와 마찬가지로 1건만 존재할 때 사용된다.**



#### ref
- eq_ref 와 달리 조인 순서와 관계 없이 사용된다. 
- pk, unique_key 가 아니어도 된다. 즉 반환 레코드가 여러 건이다.
- 인덱스 종류와 관계 없이 **동등 조건**으로 검색할 때 사용

```sql
select * from dept_table d, emp_table e
where e.emp_id = d.emp_id and d.emp_id = 1 

// 동등 조건을 사용하며 d.emp_id 는 여러 레코드를 반환한다. 

```


#### fulltext
- 전문 검색 인덱스를 사용하는 방법
- const, eq_ref, ref 다음으로 우선순위가 높다.
- fulltext 쿼리가 우선적으로 수행되는데 실제로는 다른 접근 방법이 더 빠를 수 있다. 따라서 실제 성능을 확인해봐야 한다.

#### ref_or_null
- ref 접근 방법에 null 비교가 추가된 접근 방법
- `is null` 쿼리 사용시 적용된다.


#### unique_subquery
- where 조건 절의 in 형태의 쿼리를 위한 접근 법
- 실제로는 세미 조인 최적화의 추가로인해 다른 실행 계획이 나타난다.
```sql 
select * from test_table where in ( select ~ )
```


#### index_subquery
- in 내부의 서브쿼리의 중복된 값이 인덱스를 사용해 제거할 수 있을 때 사용된다.

| 종류              | 중복 제거 작업 |
| --------------- | -------- |
| unique_subquery | x        |
| index_subquery  | o        |


#### range 
- **인덱스 레인지 스캔** 접근 방법 
  [참고] : [[책/real mysql 1/8. 인덱스#인덱스 레인지 스캔\|8. 인덱스#인덱스 레인지 스캔]]
- `<, >, is null, between, in, like` 연산자를 이용해 인덱스를 검색 시 사용

>  일반적으로 **인덱스 레인지 스캔**은 **const, ref, range** 를 모두 묶어 지칭
> 인덱스를 효율적으로 사용함을 의미


#### index_merge
- 2개 이상의 인덱스로 검색결과를 만든 후 그 결과를 병합하는 처리 방식
	- 여러 인덱스를 읽어야 하므로 **range** 보다 느림
	- 전문 검색 인덱스에서 적용 불가
	- 결과가 항상 **2개 이상의 집합**이므로 두 집합간의 **교집합, 합집합, 중복제거 연산이 추가**로 필요
- Extra 칼럼에 추가 적인 내용이 표시된다.

```sql
select * from employees 
where emp_no Between 1001 And 1100
   OR first_name ='Smith;

// first_name 에 index 존재하며, Or 집합으로 병합하기에 index_merge 사용 

```



#### index
- **인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미**
	- 즉 인덱스를 부분만 읽는 **range** 보다 효율적인 인덱스 접근 방식이 아니다.
- range,const,ref 를 사용할 수 없으며 아래 조건 중 하나를 만족할 때 사용된다.
	- **인덱스 칼럼에 포함된 값으로 처리할 수 있는 경우 (클러스터링 키에 의해 데이터 파일을 읽지 않아도 된다. 커버링 인덱스라 한다.) ** 
	- 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우


#### ALL
- **풀 테이블 스캔**시 사용되며 가장 비효율적인 방법


[참고] : [[메모/DB/인덱스 풀 스캔, 풀 테이블 스캔\|인덱스 풀 스캔, 풀 테이블 스캔]]




## 10.3.6 possible_keys 칼럼
---
- 옵티마이저가 최적의 실행 계획을 만들기 위해 **후보**로 선정 했던 접근 방법에서 사용되는 실행 계획


## 10.3.7 key 칼럼
---
- 수행된 최적의 실행 계획에 사용된 인덱스

| type        |                |
| ----------- | -------------- |
| index_merge | 두개 이상의 값 |
| ALL         | null           |


## 10.3.8 key_len 칼럼
---
- 다중 칼럼 인덱스나 혹은 인덱스 사용 시에 사용된 칼럼의 바이트 수를 나타낸다.
- 만약 int 타입의 인덱스를 기준으로 쿼리가 실행되었다면 key_len 값은 4 이다.

```sql
create table multi_index(
	pk1 int ,
	pk2 int 
	primary key(pk1,pk2)
)
```

- 위와 같은 멀티 칼럼 인덱스의 경우 key_len 이 4 라면 pk1 까지 쿼리에 사용된 것이며, 8 이라면 둘 다 사용된 것이다.

> varchar(10) 타입의 index 를 사용할 때 (utf8mb4) 40 일거라 생각 했지만 key_len = 42의 값을 가졌다. 이유는 다음과 같다.
> - null 허용의 경우 오버헤드로 1 바이트 추가
> - varchar 타입은 문자열 길이를 저장하기 위한 추가 바이트를 갖음



## 10.3.9 ref 칼럼
---
- 비교 조건으로 어떤 값이 제공됐는지 보여준다.
- const, 칼럼명으로 표기
- 조건에 연산, 내부적 형 변환 들어갔다면 func로 표기된다.



## 10.3.1 rows 칼럼
---
- 옵티마이저는 테이블의 레코드 수와 인덱스 값의 분포도를 통해 실행 계획이 얼마나 많은 레코드를 읽어야 하는지 비용을 예측한다.
- rows 칼럼은 이때 예측했던 레코드 건수를 의미하는데 쿼리 처리를 위해 읽어야 했던 레코드 전체를 의미한다.



##  filtered 칼럼
---
- rows 는 인덱스 값을 사용하는 조건에만 일치하는 레코드를 예측한 것이다.
- 실제 쿼리의 where 절에는 인덱스가 아닌 칼럼도 존재하고 이 또한 예측할 수 있어야 한다.
```sql
select * from A a B b
where A.id = 1 
and a.value between  100 and 200
and b.id = 1
and b.value between 200 and 300

// a.id, b.id 에 인덱스가 존재하고 value에 index가 존재하지 않는다  가정한다.
```
- join 쿼리에서 드라이빙 테이블은 `a.id`,`b.id` 로 우선 인덱스를 사용해 레코드 건수를 뽑아낸 후에 `value` 조건에 맞는 레코드 건수를 비교해 적은 레코드를 갖는 테이블이 선택된다.
- **filterd** 에는 `value` 에 의해 **필터링 되어 남는 값**의 비율을 표시한다.

- **더 적은 레코드 건수를 갖는 테이블을 드라이빙 테이블로 선택해야 적은 메모리를 사용하므로 filtered 의 정확도는 매우 중요하다. 인덱스가 아닌 칼럼의 정확도를 향상시키기 위해 히스토그램을 설정할 수 있다.**


## 10.3.12 Extra 칼럼
---
- 쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 표시된다.
- 내부적 알고리즘 처리에 세부 내용을 보여준다.



