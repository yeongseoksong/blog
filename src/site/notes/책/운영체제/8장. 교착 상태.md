---
{"dg-publish":true,"permalink":"///8/"}
---


**교착 상태란** 프로세스 집합 내의 모든 프로세스가 그 집합의 다른 프로세스에 의해서만 일어날 수 있는 이벤트를 기다리고 있는 상황이다.
락킹 도구들은 경쟁 조건을 회피하도록 설계 되었는데 개발자는 락이 획득 되고 방출되는 방식을 신경써야한다. 그렇지 앟으면 각 프로세스가 상대프로세스에 의해 락킹 되어있는 자원을 기다리며 교착상태에 빠질 수 있다. 교착상태는 아래의 4가지에 의해 일어난다.

- **상호배제 ( mutal exclusion )**  : 최소한 하나의 자원이 비공유 모드로 점유
- **점유하며 대기 ( hold and wait )**  : 스레드가 하나의 자원을 점유한 채 다른 스레드에 점유된 자원에 요청
- **비 선점 ( no preemption )** : 자원들을 선점할 수 없는 경우
- **순환 대기 ( circular wait )** : 대기하고 스레드 집합이 서로 점유한 자원을 연쇄적으로 요청하는 상황 

> **라이브락** : 교착상태는 라이브니스 장애에 포함되는데, 라이브락 또한 이의 한 종류이다. 라이브락은 스레드가 실패한 행동을 계속해서 시도할 때 발생한다. 이를 해결하기 위해 실패한 행동을 재시도할 때 텀을 두어야한다.
> 네트워크가 충돌시에 Ethernet 네트워크는 충돌한 호스트에 재전송을 시도하기전에 임의의 시간 이후에 재전송 한다.


#### 자원 할당 그래프 ( Resource Allocation Graph )
---
자월 할당 그래프에서 사이클이 생길 수 있는데, 한가지 자원 유형의 인스턴스 개수에 따라 다르게 적용된다.

1. 자원의 인스턴스 수가 한개인 경우 : 사이클이 존재하면 반드시 교착 생태이다.
2. 자원의 인스턴스 수가 여러개인 경우 : 사이클이 존재는 교착 상태가 존재할 수 있음을 의한다. 반드시 교착 상태가 존재하는 것은 아니다. 반대로 사이클이 없을 경우 교착 상태가 존재하지 않는다.



#### 교착상태 처리 방법
---
1. 문제를 무시하고 시스템에서 교착 상태가 발생하지 않은 척 한다. ( window, linux 에서 사용하는데 다른 처리 방법과 비교해서 비용이 적기 때문이다. )
2. 교착 상태를 **예방**하거나 **회피**하는 프로토콜을 사용한다 
3. 교착 상태를 허용하되 이를 탐지하고 복구한다.



#### 교착 상태 예방
---
교착상태 발생의 4가지 필요 조건중 최소한 한 가지가 성립하지 않게 보장한다. 
**상호 배제**
하나의 자원이 공유 불가능한 자원일 때 발생하는데, 공유 가능한 자원으로 변경하면 된다. 파일을 읽는 작업을 여러 스레드가 동시에 읽을 수 있게 허용하면 된다. 그러나 어떤 자원들 (mutex) 은 근본적으로 공유가 불가능 하다.

**점유하며 대기**
스레드가 자원을 요청할 때 다른 자원을 보유하지 않도록 보장하면 된다. 이를 위한 두가지 프로토콜은 아래와 같다. 
1. 스레드가 실행 시작하기 전에 모든 자원을 요청하고 할당.
2. 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용

그러나, 1.의 경우 자원의 이용류이 낮아지고, 2.의 경우에는 기아 상태가 발생할 수 있다.

**비선점**
1. 지니고 있던 자원이 선점된다 -> 요청한 자원을 선점해 가져온다 -> 선점 되었던 자원 도 다시 획득 한다 -> 스레드가 실행된다.
2. 대기하나 자원이 선점되지는 않는다 -> 자원을 요청 받을 경우 선점 될 수 있다. -> 필요한 자원을 요청하고 대기중인 스레드에서 자원을 선점해 가져온다 -> 만약 처음에 가지고 있던 자원도 가지고 있는 상태라면 실핸한다.

cpu 레지스터나 데이터베이스 트랜잭션 처럼 상태가 쉽게 저장되고 후에 복원 될 수 있는 자원에 적용된다.

**순환 대기**
모든 자원 유형에 전체적인 순서를 부여하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구한다.
락 순서를 부여했다고 해도 락이 동적으로 획득될 수있다면 교착 상태 예방을 보장할 수
없다.


순환 대기 조건을 회피하는것 외에는 나머지는 사용하기 어렵다. 또한, 장치의 이용률이 저하되고 시스템 총처리율이 낮아진다. 그렇기 때문에 예방보다는 회피 방법을 사용한다.

#### 교착 상태 회피
---
자원이 어떻게 요청될지에 대한 **추가 정보**를 제공하도록 요구한다. **미래에 교착상태를 피하고자 스레드가 대기해야 하는지 여부를 결정할 수 있다**.  아래의 추가 정보가 필요하다.
- 현재 가용 자원
- 현재 각 스레드에 할당된 자원
- 각 스레드가 앞으로 요청할 최대 자원 수

**안전상태** : 어떤 순서로든 스레드들이 요청하는 모든 자원을 교착 상태를 야기하지 않고 차례로 모두 할당해줄 수 있다. **안전 순서를** 찾는다. 안전 순서를 찾을 수 없다면 이를 불안전 상태라고 하는데, 불안전 상태는 교착 상태가 발생할 수도 있음을 의미한다.

교착 상태를 회피하기 위해서는 시스템의 상태가 항상 안전 상태로 유지되게 하면 된다. 
아래의 두가지 방법으로 교착 상태를 회피 가능하다.
- **자원 할당 그래프 알고리즘**  : 앞서 교착 상태 발생 유무를 확인하기 위해 사용했는데, 이를 살짝 변형하여 예약 간선을 추가한다.  사이클이 존재함은 시스템이 불안전한 상태임을 의미한다.
  그러나 , **자원의 인스턴스가 여러개면 사용이 불가능하다.**
- **은행원 알고리즘** 

#### 은행원 알고리즘
---
자연의 인스턴스가 여러개 일때 사용 가능한 교착 상태 회피 알고리즘 이다. 아래의  자료구조를 필요로 한다.
- Available : 시스템에 존재하는 가용 가능한 자원의 개수
- Max : 각 스레드가 최대로 필요로 하는 자원의  개수
- Allocation : 각 스레드에 할당된 자원의 개수
- Need : 각 스레드가 추가 적으로 필요로 하는 자원의 개수 Max-Allocation

**안정성 알고리즘** : 시스템이 안전 상태인지 확인하고 안전 순서를 찾는다.
**자원 요청 알고리즘** :자원 요청이 안전하게 들어줄 수 있는지 검사하는 알고리즘 이다. 자원 요청을 반영했을때 **상태가 안전성 알고리즘에 위배된다면 해당 요청을 들어줄 수 없다.**



#### 교착 상태 탐지
---
교착 상태 예방, 교착 상태 방지 알고리즘을 사용하지 않을 때 사용한다. 그렇기 때문에 아래의 두 알고리즘이 지원 되어야 한다.
- 교착 상태가 발생 했는지 결절 하기 위한 상태를 검사하는 알고리즘
- 교착 상태로부터 회복 하는 알고리즘


#### 교착 상태 검사 알고리즘
---

**각 자원의 유형이 한 개씩 있는 경우**
회피 방법과 마찬가지로 자원 할당 그래프를 활용할 수 있다. 이를 변형 해서 **대기 그래프 (wait for graph**)
를 사용하는데, 자원 할당 그래프에서 자원 유형의 노드를 제거하고 스레드 끼리 연결한 그래프이다.
**대기 그래프가 사이클을 포함할 때에만 교착 상태가 발생 가능성이 있다.**


**각 자원의 유형이 여러 개 가진 경우**
은행원 알고리즘을 변형한 **Shoshani 와 Coffman 알고리즘**을 사용한다.  요청 하는 자원의 개수만 확인 하면 되기 때문에 Request 자료구조만 사용한다.
- Available
- Allocation
- Request


교착 상태를 탐지하는 알고리즘은 o(n^2) 의 시간 복잡도를 요구한다. 이를 자원을 요청할때마다 호출하여 검사하면 오버헤드가 커지기 떄문에 지정된 시간을 간격으로 호출한다.



#### 교착 상태로 부터 회복
----
교착 상태가 존재한다고 결정 하면 이를 해결하기 위한 여러 방법이 있다.
1. 운영자가 수작업으로 처리
2. 시스템이 자동으로 교착 상태로부터 회복 하게 함
	- 순환 대기로를 깨트리기 위해 한개 이상의 **스레드를 중지**
	- 하나 이상의 스레드들로부터 **자원을 선점**

**프로세스와 스레드를 종료**
- 교착 상태 프로세스를 모두 중지 : 확실한 방법이지만 실행 중이던 프로세스들을 다시 계산해야하므로 비용이 크다.
- 교착 상태가 제거될 때까지 한 프로세스 씩 중지 : 각 프로세스를 중지할때 마다 교착 상태 탐지 알고리즘을 호출해 아직 프로세스들이 교착상태에 빠져있는지 확인해야하는 오버헤드가 존재한다.

**자원 선점**
교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속해서 선점해 다른 프로세스에 할당하는 방식인데 아래 세가지 사항을 고려해야한다.
- **희생자 선택 (select of a victim)** 
  어느 자원과 어느 프로세스들이 선점될것인지 최소한의 비용을 사용할 수 있는 선점 순서를 결정 해야한다.
- **후퇴 (rollback)**
  선점 당하는 프로세스를 안전한 상태로 후퇴시키고 그 상태로부터 다시 시작해야 한다. 이 프로세스가 안전 상태인지 알기 어렵기 때문에 프로세스를 중지시키고 재시작하는 방법을 사용한다.
- **기아 상태 (starvation)**
  항상 자원이 선점되어 프로세스가 실행되지 않는 기아 상태를 방지하기 위해 rollback 의 횟수를 저장해야한다.